// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
    baseUrl: string;
};

export type GetRemnawaveSettingsResponseDto = {
    response: {
        passkeySettings: {
            enabled: boolean;
            rpId: string | null;
            origin: string | null;
        } | null;
        oauth2Settings: {
            github: {
                enabled: boolean;
                clientId: string | null;
                clientSecret: string | null;
                allowedEmails: Array<string>;
            };
            pocketid: {
                enabled: boolean;
                clientId: string | null;
                clientSecret: string | null;
                plainDomain: string | null;
                allowedEmails: Array<string>;
            };
            yandex: {
                enabled: boolean;
                clientId: string | null;
                clientSecret: string | null;
                allowedEmails: Array<string>;
            };
        } | null;
        tgAuthSettings: {
            enabled: boolean;
            botToken: string | null;
            adminIds: Array<string>;
        } | null;
        passwordSettings: {
            enabled: boolean;
        } | null;
        brandingSettings: {
            title: string | null;
            logoUrl: string | null;
        } | null;
    };
};

export type UpdateRemnawaveSettingsRequestDto = {
    passkeySettings?: {
        enabled: boolean;
        rpId: string | null;
        origin: string | null;
    };
    oauth2Settings?: {
        github: {
            enabled: boolean;
            clientId: string | null;
            clientSecret: string | null;
            allowedEmails: Array<string>;
        };
        pocketid: {
            enabled: boolean;
            clientId: string | null;
            clientSecret: string | null;
            plainDomain: string | null;
            allowedEmails: Array<string>;
        };
        yandex: {
            enabled: boolean;
            clientId: string | null;
            clientSecret: string | null;
            allowedEmails: Array<string>;
        };
    };
    tgAuthSettings?: {
        enabled: boolean;
        botToken: string | null;
        adminIds: Array<string>;
    };
    passwordSettings?: {
        enabled: boolean;
    };
    brandingSettings?: {
        title: string | null;
        logoUrl: string | null;
    };
};

export type UpdateRemnawaveSettingsResponseDto = {
    response: {
        passkeySettings: {
            enabled: boolean;
            rpId: string | null;
            origin: string | null;
        } | null;
        oauth2Settings: {
            github: {
                enabled: boolean;
                clientId: string | null;
                clientSecret: string | null;
                allowedEmails: Array<string>;
            };
            pocketid: {
                enabled: boolean;
                clientId: string | null;
                clientSecret: string | null;
                plainDomain: string | null;
                allowedEmails: Array<string>;
            };
            yandex: {
                enabled: boolean;
                clientId: string | null;
                clientSecret: string | null;
                allowedEmails: Array<string>;
            };
        } | null;
        tgAuthSettings: {
            enabled: boolean;
            botToken: string | null;
            adminIds: Array<string>;
        } | null;
        passwordSettings: {
            enabled: boolean;
        } | null;
        brandingSettings: {
            title: string | null;
            logoUrl: string | null;
        } | null;
    };
};

export type GetPasskeyRegistrationOptionsResponseDto = {
    response: unknown;
};

export type VerifyPasskeyRegistrationRequestDto = {
    response: unknown;
};

export type VerifyPasskeyRegistrationResponseDto = {
    response: {
        verified: boolean;
    };
};

export type GetAllPasskeysResponseDto = {
    response: {
        passkeys: Array<{
            id: string;
            name: string;
            /**
             * Created date. Format: 2025-01-17T15:38:45.065Z
             */
            createdAt: string;
            /**
             * Last used date. Format: 2025-01-17T15:38:45.065Z
             */
            lastUsedAt: string;
        }>;
    };
};

export type DeletePasskeyRequestDto = {
    id: string;
};

export type DeletePasskeyResponseDto = {
    response: {
        passkeys: Array<{
            id: string;
            name: string;
            /**
             * Created date. Format: 2025-01-17T15:38:45.065Z
             */
            createdAt: string;
            /**
             * Last used date. Format: 2025-01-17T15:38:45.065Z
             */
            lastUsedAt: string;
        }>;
    };
};

export type UpdatePasskeyRequestDto = {
    id: string;
    name: string;
};

export type UpdatePasskeyResponseDto = {
    response: {
        passkeys: Array<{
            id: string;
            name: string;
            /**
             * Created date. Format: 2025-01-17T15:38:45.065Z
             */
            createdAt: string;
            /**
             * Last used date. Format: 2025-01-17T15:38:45.065Z
             */
            lastUsedAt: string;
        }>;
    };
};

export type LoginRequestDto = {
    username: string;
    password: string;
};

export type LoginResponseDto = {
    response: {
        accessToken: string;
    };
};

export type RegisterRequestDto = {
    username: string;
    password: string;
};

export type RegisterResponseDto = {
    response: {
        accessToken: string;
    };
};

export type GetStatusResponseDto = {
    response: {
        isLoginAllowed: boolean;
        isRegisterAllowed: boolean;
        authentication: {
            passkey: {
                enabled: boolean;
            };
            tgAuth: {
                enabled: boolean;
                botId: number | null;
            };
            oauth2: {
                providers: {
                    [key: string]: boolean;
                };
            };
            password: {
                enabled: boolean;
            };
        } | null;
        branding: {
            title: string | null;
            logoUrl: string | null;
        };
    };
};

export type TelegramCallbackRequestDto = {
    id: number;
    first_name: string;
    last_name?: string;
    username?: string;
    photo_url?: string;
    auth_date: number;
    hash: string;
};

export type TelegramCallbackResponseDto = {
    response: {
        accessToken: string;
    };
};

export type OAuth2AuthorizeRequestDto = {
    provider: 'github' | 'pocketid' | 'yandex';
};

export type OAuth2AuthorizeResponseDto = {
    response: {
        authorizationUrl: string | null;
    };
};

export type OAuth2CallbackRequestDto = {
    provider: 'github' | 'pocketid' | 'yandex';
    code: string;
    state: string;
};

export type OAuth2CallbackResponseDto = {
    response: {
        accessToken: string;
    };
};

export type GetPasskeyAuthenticationOptionsResponseDto = {
    response: unknown;
};

export type VerifyPasskeyAuthenticationRequestDto = {
    response: unknown;
};

export type VerifyPasskeyAuthenticationResponseDto = {
    response: {
        accessToken: string;
    };
};

export type CreateUserRequestDto = {
    /**
     * Unique username for the user. Required. Must be 3-36 characters long and contain only letters, numbers, underscores and dashes.
     */
    username: string;
    /**
     * Optional. User account status. Defaults to ACTIVE.
     */
    status?: 'ACTIVE' | 'DISABLED' | 'LIMITED' | 'EXPIRED';
    /**
     * Optional. Short UUID identifier for the user.
     */
    shortUuid?: string;
    /**
     * Optional. Password for Trojan protocol. Must be 8-32 characters.
     */
    trojanPassword?: string;
    /**
     * Optional. UUID for VLESS protocol. Must be a valid UUID format.
     */
    vlessUuid?: string;
    /**
     * Optional. Password for Shadowsocks protocol. Must be 8-32 characters.
     */
    ssPassword?: string;
    /**
     * Optional. Traffic limit in bytes. Set to 0 for unlimited traffic.
     */
    trafficLimitBytes?: number;
    /**
     * Available reset periods
     */
    trafficLimitStrategy?: 'NO_RESET' | 'DAY' | 'WEEK' | 'MONTH';
    /**
     * Account expiration date. Required. Format: 2025-01-17T15:38:45.065Z
     */
    expireAt: string;
    /**
     * Optional. Account creation date. Format: 2025-01-17T15:38:45.065Z
     */
    createdAt?: string;
    /**
     * Optional. Date of last traffic reset. Format: 2025-01-17T15:38:45.065Z
     */
    lastTrafficResetAt?: string;
    /**
     * Optional. Additional notes or description for the user account.
     */
    description?: string;
    /**
     * Optional. User tag for categorization. Max 16 characters, uppercase letters, numbers and underscores only.
     */
    tag?: string | null;
    /**
     * Optional. Telegram user ID for notifications. Must be an integer.
     */
    telegramId?: number | null;
    /**
     * Optional. User email address. Must be a valid email format.
     */
    email?: string | null;
    /**
     * Optional. Maximum number of hardware devices allowed. Must be a positive integer.
     */
    hwidDeviceLimit?: number;
    /**
     * Optional. Array of UUIDs representing enabled internal squads.
     */
    activeInternalSquads?: Array<string>;
    /**
     * Optional. Pass UUID to create user with specific UUID, otherwise it will be generated automatically.
     */
    uuid?: string;
    /**
     * Optional. External squad UUID.
     */
    externalSquadUuid?: string | null;
};

export type CreateUserResponseDto = {
    response: {
        uuid: string;
        id: number;
        shortUuid: string;
        username: string;
        status?: 'ACTIVE' | 'DISABLED' | 'LIMITED' | 'EXPIRED';
        trafficLimitBytes?: number;
        /**
         * Available reset periods
         */
        trafficLimitStrategy?: 'NO_RESET' | 'DAY' | 'WEEK' | 'MONTH';
        expireAt: string;
        telegramId: number | null;
        email: string | null;
        description: string | null;
        tag: string | null;
        hwidDeviceLimit: number | null;
        externalSquadUuid: string | null;
        trojanPassword: string;
        vlessUuid: string;
        ssPassword: string;
        lastTriggeredThreshold?: number;
        subRevokedAt: string | null;
        subLastUserAgent: string | null;
        subLastOpenedAt: string | null;
        lastTrafficResetAt: string | null;
        createdAt: string;
        updatedAt: string;
        subscriptionUrl: string;
        activeInternalSquads: Array<{
            uuid: string;
            name: string;
        }>;
        userTraffic: {
            usedTrafficBytes: number;
            lifetimeUsedTrafficBytes: number;
            onlineAt: string | null;
            firstConnectedAt: string | null;
            lastConnectedNodeUuid: string | null;
        };
    };
};

export type UpdateUserRequestDto = {
    /**
     * Username of the user
     */
    username?: string;
    /**
     * UUID of the user. UUID has higher priority than username, so if both are provided, username will be ignored.
     */
    uuid?: string;
    status?: 'ACTIVE' | 'DISABLED';
    /**
     * Traffic limit in bytes. 0 - unlimited
     */
    trafficLimitBytes?: number;
    /**
     * Available reset periods
     */
    trafficLimitStrategy?: 'NO_RESET' | 'DAY' | 'WEEK' | 'MONTH';
    /**
     * Expiration date: 2025-01-17T15:38:45.065Z
     */
    expireAt?: string;
    description?: string | null;
    tag?: string | null;
    telegramId?: number | null;
    email?: string | null;
    hwidDeviceLimit?: number | null;
    activeInternalSquads?: Array<string>;
    /**
     * Optional. External squad UUID.
     */
    externalSquadUuid?: string | null;
};

export type UpdateUserResponseDto = {
    response: {
        uuid: string;
        id: number;
        shortUuid: string;
        username: string;
        status?: 'ACTIVE' | 'DISABLED' | 'LIMITED' | 'EXPIRED';
        trafficLimitBytes?: number;
        /**
         * Available reset periods
         */
        trafficLimitStrategy?: 'NO_RESET' | 'DAY' | 'WEEK' | 'MONTH';
        expireAt: string;
        telegramId: number | null;
        email: string | null;
        description: string | null;
        tag: string | null;
        hwidDeviceLimit: number | null;
        externalSquadUuid: string | null;
        trojanPassword: string;
        vlessUuid: string;
        ssPassword: string;
        lastTriggeredThreshold?: number;
        subRevokedAt: string | null;
        subLastUserAgent: string | null;
        subLastOpenedAt: string | null;
        lastTrafficResetAt: string | null;
        createdAt: string;
        updatedAt: string;
        subscriptionUrl: string;
        activeInternalSquads: Array<{
            uuid: string;
            name: string;
        }>;
        userTraffic: {
            usedTrafficBytes: number;
            lifetimeUsedTrafficBytes: number;
            onlineAt: string | null;
            firstConnectedAt: string | null;
            lastConnectedNodeUuid: string | null;
        };
    };
};

export type DeleteUserResponseDto = {
    response: {
        isDeleted: boolean;
    };
};

export type GetAllUsersResponseDto = {
    response: {
        users: Array<{
            uuid: string;
            id: number;
            shortUuid: string;
            username: string;
            status?: 'ACTIVE' | 'DISABLED' | 'LIMITED' | 'EXPIRED';
            trafficLimitBytes?: number;
            /**
             * Available reset periods
             */
            trafficLimitStrategy?: 'NO_RESET' | 'DAY' | 'WEEK' | 'MONTH';
            expireAt: string;
            telegramId: number | null;
            email: string | null;
            description: string | null;
            tag: string | null;
            hwidDeviceLimit: number | null;
            externalSquadUuid: string | null;
            trojanPassword: string;
            vlessUuid: string;
            ssPassword: string;
            lastTriggeredThreshold?: number;
            subRevokedAt: string | null;
            subLastUserAgent: string | null;
            subLastOpenedAt: string | null;
            lastTrafficResetAt: string | null;
            createdAt: string;
            updatedAt: string;
            subscriptionUrl: string;
            activeInternalSquads: Array<{
                uuid: string;
                name: string;
            }>;
            userTraffic: {
                usedTrafficBytes: number;
                lifetimeUsedTrafficBytes: number;
                onlineAt: string | null;
                firstConnectedAt: string | null;
                lastConnectedNodeUuid: string | null;
            };
        }>;
        total: number;
    };
};

export type GetAllTagsResponseDto = {
    response: {
        tags: Array<string>;
    };
};

export type GetUserAccessibleNodesResponseDto = {
    response: {
        userUuid: string;
        activeNodes: Array<{
            uuid: string;
            nodeName: string;
            countryCode: string;
            configProfileUuid: string;
            configProfileName: string;
            activeSquads: Array<{
                squadName: string;
                activeInbounds: Array<string>;
            }>;
        }>;
    };
};

export type GetUserSubscriptionRequestHistoryResponseDto = {
    response: {
        total: number;
        records: Array<{
            id: number;
            userUuid: string;
            requestAt: string;
            requestIp: string | null;
            userAgent: string | null;
        }>;
    };
};

export type GetUserByShortUuidResponseDto = {
    response: {
        uuid: string;
        id: number;
        shortUuid: string;
        username: string;
        status?: 'ACTIVE' | 'DISABLED' | 'LIMITED' | 'EXPIRED';
        trafficLimitBytes?: number;
        /**
         * Available reset periods
         */
        trafficLimitStrategy?: 'NO_RESET' | 'DAY' | 'WEEK' | 'MONTH';
        expireAt: string;
        telegramId: number | null;
        email: string | null;
        description: string | null;
        tag: string | null;
        hwidDeviceLimit: number | null;
        externalSquadUuid: string | null;
        trojanPassword: string;
        vlessUuid: string;
        ssPassword: string;
        lastTriggeredThreshold?: number;
        subRevokedAt: string | null;
        subLastUserAgent: string | null;
        subLastOpenedAt: string | null;
        lastTrafficResetAt: string | null;
        createdAt: string;
        updatedAt: string;
        subscriptionUrl: string;
        activeInternalSquads: Array<{
            uuid: string;
            name: string;
        }>;
        userTraffic: {
            usedTrafficBytes: number;
            lifetimeUsedTrafficBytes: number;
            onlineAt: string | null;
            firstConnectedAt: string | null;
            lastConnectedNodeUuid: string | null;
        };
    };
};

export type GetUserByUuidResponseDto = {
    response: {
        uuid: string;
        id: number;
        shortUuid: string;
        username: string;
        status?: 'ACTIVE' | 'DISABLED' | 'LIMITED' | 'EXPIRED';
        trafficLimitBytes?: number;
        /**
         * Available reset periods
         */
        trafficLimitStrategy?: 'NO_RESET' | 'DAY' | 'WEEK' | 'MONTH';
        expireAt: string;
        telegramId: number | null;
        email: string | null;
        description: string | null;
        tag: string | null;
        hwidDeviceLimit: number | null;
        externalSquadUuid: string | null;
        trojanPassword: string;
        vlessUuid: string;
        ssPassword: string;
        lastTriggeredThreshold?: number;
        subRevokedAt: string | null;
        subLastUserAgent: string | null;
        subLastOpenedAt: string | null;
        lastTrafficResetAt: string | null;
        createdAt: string;
        updatedAt: string;
        subscriptionUrl: string;
        activeInternalSquads: Array<{
            uuid: string;
            name: string;
        }>;
        userTraffic: {
            usedTrafficBytes: number;
            lifetimeUsedTrafficBytes: number;
            onlineAt: string | null;
            firstConnectedAt: string | null;
            lastConnectedNodeUuid: string | null;
        };
    };
};

export type GetUserByUsernameResponseDto = {
    response: {
        uuid: string;
        id: number;
        shortUuid: string;
        username: string;
        status?: 'ACTIVE' | 'DISABLED' | 'LIMITED' | 'EXPIRED';
        trafficLimitBytes?: number;
        /**
         * Available reset periods
         */
        trafficLimitStrategy?: 'NO_RESET' | 'DAY' | 'WEEK' | 'MONTH';
        expireAt: string;
        telegramId: number | null;
        email: string | null;
        description: string | null;
        tag: string | null;
        hwidDeviceLimit: number | null;
        externalSquadUuid: string | null;
        trojanPassword: string;
        vlessUuid: string;
        ssPassword: string;
        lastTriggeredThreshold?: number;
        subRevokedAt: string | null;
        subLastUserAgent: string | null;
        subLastOpenedAt: string | null;
        lastTrafficResetAt: string | null;
        createdAt: string;
        updatedAt: string;
        subscriptionUrl: string;
        activeInternalSquads: Array<{
            uuid: string;
            name: string;
        }>;
        userTraffic: {
            usedTrafficBytes: number;
            lifetimeUsedTrafficBytes: number;
            onlineAt: string | null;
            firstConnectedAt: string | null;
            lastConnectedNodeUuid: string | null;
        };
    };
};

export type GetUserByIdResponseDto = {
    response: {
        uuid: string;
        id: number;
        shortUuid: string;
        username: string;
        status?: 'ACTIVE' | 'DISABLED' | 'LIMITED' | 'EXPIRED';
        trafficLimitBytes?: number;
        /**
         * Available reset periods
         */
        trafficLimitStrategy?: 'NO_RESET' | 'DAY' | 'WEEK' | 'MONTH';
        expireAt: string;
        telegramId: number | null;
        email: string | null;
        description: string | null;
        tag: string | null;
        hwidDeviceLimit: number | null;
        externalSquadUuid: string | null;
        trojanPassword: string;
        vlessUuid: string;
        ssPassword: string;
        lastTriggeredThreshold?: number;
        subRevokedAt: string | null;
        subLastUserAgent: string | null;
        subLastOpenedAt: string | null;
        lastTrafficResetAt: string | null;
        createdAt: string;
        updatedAt: string;
        subscriptionUrl: string;
        activeInternalSquads: Array<{
            uuid: string;
            name: string;
        }>;
        userTraffic: {
            usedTrafficBytes: number;
            lifetimeUsedTrafficBytes: number;
            onlineAt: string | null;
            firstConnectedAt: string | null;
            lastConnectedNodeUuid: string | null;
        };
    };
};

export type GetUserByTelegramIdResponseDto = {
    response: Array<{
        uuid: string;
        id: number;
        shortUuid: string;
        username: string;
        status?: 'ACTIVE' | 'DISABLED' | 'LIMITED' | 'EXPIRED';
        trafficLimitBytes?: number;
        /**
         * Available reset periods
         */
        trafficLimitStrategy?: 'NO_RESET' | 'DAY' | 'WEEK' | 'MONTH';
        expireAt: string;
        telegramId: number | null;
        email: string | null;
        description: string | null;
        tag: string | null;
        hwidDeviceLimit: number | null;
        externalSquadUuid: string | null;
        trojanPassword: string;
        vlessUuid: string;
        ssPassword: string;
        lastTriggeredThreshold?: number;
        subRevokedAt: string | null;
        subLastUserAgent: string | null;
        subLastOpenedAt: string | null;
        lastTrafficResetAt: string | null;
        createdAt: string;
        updatedAt: string;
        subscriptionUrl: string;
        activeInternalSquads: Array<{
            uuid: string;
            name: string;
        }>;
        userTraffic: {
            usedTrafficBytes: number;
            lifetimeUsedTrafficBytes: number;
            onlineAt: string | null;
            firstConnectedAt: string | null;
            lastConnectedNodeUuid: string | null;
        };
    }>;
};

export type GetUserByEmailResponseDto = {
    response: Array<{
        uuid: string;
        id: number;
        shortUuid: string;
        username: string;
        status?: 'ACTIVE' | 'DISABLED' | 'LIMITED' | 'EXPIRED';
        trafficLimitBytes?: number;
        /**
         * Available reset periods
         */
        trafficLimitStrategy?: 'NO_RESET' | 'DAY' | 'WEEK' | 'MONTH';
        expireAt: string;
        telegramId: number | null;
        email: string | null;
        description: string | null;
        tag: string | null;
        hwidDeviceLimit: number | null;
        externalSquadUuid: string | null;
        trojanPassword: string;
        vlessUuid: string;
        ssPassword: string;
        lastTriggeredThreshold?: number;
        subRevokedAt: string | null;
        subLastUserAgent: string | null;
        subLastOpenedAt: string | null;
        lastTrafficResetAt: string | null;
        createdAt: string;
        updatedAt: string;
        subscriptionUrl: string;
        activeInternalSquads: Array<{
            uuid: string;
            name: string;
        }>;
        userTraffic: {
            usedTrafficBytes: number;
            lifetimeUsedTrafficBytes: number;
            onlineAt: string | null;
            firstConnectedAt: string | null;
            lastConnectedNodeUuid: string | null;
        };
    }>;
};

export type GetUserByTagResponseDto = {
    response: Array<{
        uuid: string;
        id: number;
        shortUuid: string;
        username: string;
        status?: 'ACTIVE' | 'DISABLED' | 'LIMITED' | 'EXPIRED';
        trafficLimitBytes?: number;
        /**
         * Available reset periods
         */
        trafficLimitStrategy?: 'NO_RESET' | 'DAY' | 'WEEK' | 'MONTH';
        expireAt: string;
        telegramId: number | null;
        email: string | null;
        description: string | null;
        tag: string | null;
        hwidDeviceLimit: number | null;
        externalSquadUuid: string | null;
        trojanPassword: string;
        vlessUuid: string;
        ssPassword: string;
        lastTriggeredThreshold?: number;
        subRevokedAt: string | null;
        subLastUserAgent: string | null;
        subLastOpenedAt: string | null;
        lastTrafficResetAt: string | null;
        createdAt: string;
        updatedAt: string;
        subscriptionUrl: string;
        activeInternalSquads: Array<{
            uuid: string;
            name: string;
        }>;
        userTraffic: {
            usedTrafficBytes: number;
            lifetimeUsedTrafficBytes: number;
            onlineAt: string | null;
            firstConnectedAt: string | null;
            lastConnectedNodeUuid: string | null;
        };
    }>;
};

export type RevokeUserSubscriptionBodyDto = {
    /**
     * Optional. If not provided, a new short UUID will be generated by Remnawave. Please note that it is strongly recommended to allow Remnawave to generate the short UUID.
     */
    shortUuid?: string;
};

export type RevokeUserSubscriptionResponseDto = {
    response: {
        uuid: string;
        id: number;
        shortUuid: string;
        username: string;
        status?: 'ACTIVE' | 'DISABLED' | 'LIMITED' | 'EXPIRED';
        trafficLimitBytes?: number;
        /**
         * Available reset periods
         */
        trafficLimitStrategy?: 'NO_RESET' | 'DAY' | 'WEEK' | 'MONTH';
        expireAt: string;
        telegramId: number | null;
        email: string | null;
        description: string | null;
        tag: string | null;
        hwidDeviceLimit: number | null;
        externalSquadUuid: string | null;
        trojanPassword: string;
        vlessUuid: string;
        ssPassword: string;
        lastTriggeredThreshold?: number;
        subRevokedAt: string | null;
        subLastUserAgent: string | null;
        subLastOpenedAt: string | null;
        lastTrafficResetAt: string | null;
        createdAt: string;
        updatedAt: string;
        subscriptionUrl: string;
        activeInternalSquads: Array<{
            uuid: string;
            name: string;
        }>;
        userTraffic: {
            usedTrafficBytes: number;
            lifetimeUsedTrafficBytes: number;
            onlineAt: string | null;
            firstConnectedAt: string | null;
            lastConnectedNodeUuid: string | null;
        };
    };
};

export type DisableUserResponseDto = {
    response: {
        uuid: string;
        id: number;
        shortUuid: string;
        username: string;
        status?: 'ACTIVE' | 'DISABLED' | 'LIMITED' | 'EXPIRED';
        trafficLimitBytes?: number;
        /**
         * Available reset periods
         */
        trafficLimitStrategy?: 'NO_RESET' | 'DAY' | 'WEEK' | 'MONTH';
        expireAt: string;
        telegramId: number | null;
        email: string | null;
        description: string | null;
        tag: string | null;
        hwidDeviceLimit: number | null;
        externalSquadUuid: string | null;
        trojanPassword: string;
        vlessUuid: string;
        ssPassword: string;
        lastTriggeredThreshold?: number;
        subRevokedAt: string | null;
        subLastUserAgent: string | null;
        subLastOpenedAt: string | null;
        lastTrafficResetAt: string | null;
        createdAt: string;
        updatedAt: string;
        subscriptionUrl: string;
        activeInternalSquads: Array<{
            uuid: string;
            name: string;
        }>;
        userTraffic: {
            usedTrafficBytes: number;
            lifetimeUsedTrafficBytes: number;
            onlineAt: string | null;
            firstConnectedAt: string | null;
            lastConnectedNodeUuid: string | null;
        };
    };
};

export type EnableUserResponseDto = {
    response: {
        uuid: string;
        id: number;
        shortUuid: string;
        username: string;
        status?: 'ACTIVE' | 'DISABLED' | 'LIMITED' | 'EXPIRED';
        trafficLimitBytes?: number;
        /**
         * Available reset periods
         */
        trafficLimitStrategy?: 'NO_RESET' | 'DAY' | 'WEEK' | 'MONTH';
        expireAt: string;
        telegramId: number | null;
        email: string | null;
        description: string | null;
        tag: string | null;
        hwidDeviceLimit: number | null;
        externalSquadUuid: string | null;
        trojanPassword: string;
        vlessUuid: string;
        ssPassword: string;
        lastTriggeredThreshold?: number;
        subRevokedAt: string | null;
        subLastUserAgent: string | null;
        subLastOpenedAt: string | null;
        lastTrafficResetAt: string | null;
        createdAt: string;
        updatedAt: string;
        subscriptionUrl: string;
        activeInternalSquads: Array<{
            uuid: string;
            name: string;
        }>;
        userTraffic: {
            usedTrafficBytes: number;
            lifetimeUsedTrafficBytes: number;
            onlineAt: string | null;
            firstConnectedAt: string | null;
            lastConnectedNodeUuid: string | null;
        };
    };
};

export type ResetUserTrafficResponseDto = {
    response: {
        uuid: string;
        id: number;
        shortUuid: string;
        username: string;
        status?: 'ACTIVE' | 'DISABLED' | 'LIMITED' | 'EXPIRED';
        trafficLimitBytes?: number;
        /**
         * Available reset periods
         */
        trafficLimitStrategy?: 'NO_RESET' | 'DAY' | 'WEEK' | 'MONTH';
        expireAt: string;
        telegramId: number | null;
        email: string | null;
        description: string | null;
        tag: string | null;
        hwidDeviceLimit: number | null;
        externalSquadUuid: string | null;
        trojanPassword: string;
        vlessUuid: string;
        ssPassword: string;
        lastTriggeredThreshold?: number;
        subRevokedAt: string | null;
        subLastUserAgent: string | null;
        subLastOpenedAt: string | null;
        lastTrafficResetAt: string | null;
        createdAt: string;
        updatedAt: string;
        subscriptionUrl: string;
        activeInternalSquads: Array<{
            uuid: string;
            name: string;
        }>;
        userTraffic: {
            usedTrafficBytes: number;
            lifetimeUsedTrafficBytes: number;
            onlineAt: string | null;
            firstConnectedAt: string | null;
            lastConnectedNodeUuid: string | null;
        };
    };
};

export type BulkDeleteUsersByStatusRequestDto = {
    status?: 'ACTIVE' | 'DISABLED' | 'LIMITED' | 'EXPIRED';
};

export type BulkDeleteUsersByStatusResponseDto = {
    response: {
        affectedRows: number;
    };
};

export type BulkDeleteUsersRequestDto = {
    uuids: Array<string>;
};

export type BulkDeleteUsersResponseDto = {
    response: {
        affectedRows: number;
    };
};

export type BulkRevokeUsersSubscriptionRequestDto = {
    uuids: Array<string>;
};

export type BulkRevokeUsersSubscriptionResponseDto = {
    response: {
        affectedRows: number;
    };
};

export type BulkResetTrafficUsersRequestDto = {
    uuids: Array<string>;
};

export type BulkResetTrafficUsersResponseDto = {
    response: {
        affectedRows: number;
    };
};

export type BulkUpdateUsersRequestDto = {
    uuids: Array<string>;
    fields: {
        status?: 'ACTIVE' | 'DISABLED' | 'LIMITED' | 'EXPIRED';
        /**
         * Traffic limit in bytes. 0 - unlimited
         */
        trafficLimitBytes?: number;
        /**
         * Traffic limit reset strategy
         */
        trafficLimitStrategy?: 'NO_RESET' | 'DAY' | 'WEEK' | 'MONTH';
        /**
         * Expiration date: 2025-01-17T15:38:45.065Z
         */
        expireAt?: string;
        description?: string | null;
        telegramId?: number | null;
        email?: string | null;
        tag?: string | null;
        hwidDeviceLimit?: number | null;
        /**
         * Optional. External squad UUID.
         */
        externalSquadUuid?: string | null;
    };
};

export type BulkUpdateUsersResponseDto = {
    response: {
        affectedRows: number;
    };
};

export type BulkUpdateUsersSquadsRequestDto = {
    uuids: Array<string>;
    activeInternalSquads: Array<string>;
};

export type BulkUpdateUsersSquadsResponseDto = {
    response: {
        affectedRows: number;
    };
};

export type BulkExtendExpirationDateRequestDto = {
    uuids: Array<string>;
    extendDays: number;
};

export type BulkExtendExpirationDateResponseDto = {
    response: {
        affectedRows: number;
    };
};

export type BulkAllUpdateUsersRequestDto = {
    status?: 'ACTIVE' | 'DISABLED' | 'LIMITED' | 'EXPIRED';
    /**
     * Traffic limit in bytes. 0 - unlimited
     */
    trafficLimitBytes?: number;
    /**
     * Traffic limit reset strategy
     */
    trafficLimitStrategy?: 'NO_RESET' | 'DAY' | 'WEEK' | 'MONTH';
    /**
     * Expiration date: 2025-01-17T15:38:45.065Z
     */
    expireAt?: string;
    description?: string | null;
    telegramId?: number | null;
    email?: string | null;
    tag?: string | null;
    hwidDeviceLimit?: number | null;
};

export type BulkAllUpdateUsersResponseDto = {
    response: {
        eventSent: boolean;
    };
};

export type BulkAllResetTrafficUsersResponseDto = {
    response: {
        eventSent: boolean;
    };
};

export type BulkAllExtendExpirationDateRequestDto = {
    extendDays: number;
};

export type BulkAllExtendExpirationDateResponseDto = {
    response: {
        eventSent: boolean;
    };
};

export type GetUserUsageByRangeResponseDto = {
    response: Array<{
        userUuid: string;
        nodeUuid: string;
        nodeName: string;
        countryCode: string;
        total: number;
        date: string;
    }>;
};

export type GetSubscriptionInfoResponseDto = {
    response: {
        isFound: boolean;
        user: {
            shortUuid: string;
            daysLeft: number;
            trafficUsed: string;
            trafficLimit: string;
            lifetimeTrafficUsed: string;
            trafficUsedBytes: string;
            trafficLimitBytes: string;
            lifetimeTrafficUsedBytes: string;
            username: string;
            expiresAt: string;
            isActive: boolean;
            userStatus: 'ACTIVE' | 'DISABLED' | 'LIMITED' | 'EXPIRED';
            trafficLimitStrategy: 'NO_RESET' | 'DAY' | 'WEEK' | 'MONTH';
        };
        links: Array<string>;
        ssConfLinks: {
            [key: string]: string;
        };
        subscriptionUrl: string;
    };
};

export type GetAllSubscriptionsResponseDto = {
    response: {
        subscriptions: Array<{
            isFound: boolean;
            user: {
                shortUuid: string;
                daysLeft: number;
                trafficUsed: string;
                trafficLimit: string;
                lifetimeTrafficUsed: string;
                trafficUsedBytes: string;
                trafficLimitBytes: string;
                lifetimeTrafficUsedBytes: string;
                username: string;
                expiresAt: string;
                isActive: boolean;
                userStatus: 'ACTIVE' | 'DISABLED' | 'LIMITED' | 'EXPIRED';
                trafficLimitStrategy: 'NO_RESET' | 'DAY' | 'WEEK' | 'MONTH';
            };
            links: Array<string>;
            ssConfLinks: {
                [key: string]: string;
            };
            subscriptionUrl: string;
        }>;
        total: number;
    };
};

export type GetSubscriptionByUsernameResponseDto = {
    response: {
        isFound: boolean;
        user: {
            shortUuid: string;
            daysLeft: number;
            trafficUsed: string;
            trafficLimit: string;
            lifetimeTrafficUsed: string;
            trafficUsedBytes: string;
            trafficLimitBytes: string;
            lifetimeTrafficUsedBytes: string;
            username: string;
            expiresAt: string;
            isActive: boolean;
            userStatus: 'ACTIVE' | 'DISABLED' | 'LIMITED' | 'EXPIRED';
            trafficLimitStrategy: 'NO_RESET' | 'DAY' | 'WEEK' | 'MONTH';
        };
        links: Array<string>;
        ssConfLinks: {
            [key: string]: string;
        };
        subscriptionUrl: string;
    };
};

export type GetSubscriptionByShortUuidProtectedResponseDto = {
    response: {
        isFound: boolean;
        user: {
            shortUuid: string;
            daysLeft: number;
            trafficUsed: string;
            trafficLimit: string;
            lifetimeTrafficUsed: string;
            trafficUsedBytes: string;
            trafficLimitBytes: string;
            lifetimeTrafficUsedBytes: string;
            username: string;
            expiresAt: string;
            isActive: boolean;
            userStatus: 'ACTIVE' | 'DISABLED' | 'LIMITED' | 'EXPIRED';
            trafficLimitStrategy: 'NO_RESET' | 'DAY' | 'WEEK' | 'MONTH';
        };
        links: Array<string>;
        ssConfLinks: {
            [key: string]: string;
        };
        subscriptionUrl: string;
    };
};

export type GetSubscriptionByUuidResponseDto = {
    response: {
        isFound: boolean;
        user: {
            shortUuid: string;
            daysLeft: number;
            trafficUsed: string;
            trafficLimit: string;
            lifetimeTrafficUsed: string;
            trafficUsedBytes: string;
            trafficLimitBytes: string;
            lifetimeTrafficUsedBytes: string;
            username: string;
            expiresAt: string;
            isActive: boolean;
            userStatus: 'ACTIVE' | 'DISABLED' | 'LIMITED' | 'EXPIRED';
            trafficLimitStrategy: 'NO_RESET' | 'DAY' | 'WEEK' | 'MONTH';
        };
        links: Array<string>;
        ssConfLinks: {
            [key: string]: string;
        };
        subscriptionUrl: string;
    };
};

export type GetRawSubscriptionByShortUuidResponseDto = {
    response: {
        user: {
            uuid: string;
            id: number;
            shortUuid: string;
            username: string;
            status?: 'ACTIVE' | 'DISABLED' | 'LIMITED' | 'EXPIRED';
            trafficLimitBytes?: number;
            /**
             * Available reset periods
             */
            trafficLimitStrategy?: 'NO_RESET' | 'DAY' | 'WEEK' | 'MONTH';
            expireAt: string;
            telegramId: number | null;
            email: string | null;
            description: string | null;
            tag: string | null;
            hwidDeviceLimit: number | null;
            externalSquadUuid: string | null;
            trojanPassword: string;
            vlessUuid: string;
            ssPassword: string;
            lastTriggeredThreshold?: number;
            subRevokedAt: string | null;
            subLastUserAgent: string | null;
            subLastOpenedAt: string | null;
            lastTrafficResetAt: string | null;
            createdAt: string;
            updatedAt: string;
            subscriptionUrl: string;
            activeInternalSquads: Array<{
                uuid: string;
                name: string;
            }>;
            userTraffic: {
                usedTrafficBytes: number;
                lifetimeUsedTrafficBytes: number;
                onlineAt: string | null;
                firstConnectedAt: string | null;
                lastConnectedNodeUuid: string | null;
            };
        };
        convertedUserInfo: {
            daysLeft: number;
            trafficLimit: string;
            trafficUsed: string;
            lifetimeTrafficUsed: string;
            isHwidLimited: boolean;
        };
        headers: {
            [key: string]: string;
        };
        rawHosts: Array<{
            address?: string | null;
            alpn?: string | null;
            fingerprint?: string | null;
            host?: string | null;
            network?: string | null;
            password: {
                ssPassword: string;
                trojanPassword: string;
                vlessPassword: string;
            };
            path?: string | null;
            publicKey?: string | null;
            port?: number | null;
            protocol?: string | null;
            remark?: string | null;
            shortId?: string | null;
            sni?: string | null;
            spiderX?: string | null;
            tls?: string | null;
            rawSettings?: {
                headerType?: string | null;
                request?: {
                    [key: string]: unknown;
                } | null;
            } | null;
            additionalParams?: {
                mode?: string | null;
                heartbeatPeriod?: number | null;
            } | null;
            xHttpExtraParams?: {
                [key: string]: unknown;
            } | null;
            muxParams?: {
                [key: string]: unknown;
            } | null;
            sockoptParams?: {
                [key: string]: unknown;
            } | null;
            serverDescription?: string | null;
            flow?: string | null;
            allowInsecure?: boolean | null;
            shuffleHost?: boolean | null;
            mihomoX25519?: boolean | null;
            mldsa65Verify?: string | null;
            encryption?: string | null;
            protocolOptions?: {
                ss?: {
                    method?: string | null;
                } | null;
            } | null;
            dbData?: {
                rawInbound: {
                    [key: string]: unknown;
                } | null;
                inboundTag: string;
                uuid: string;
                configProfileUuid: string | null;
                configProfileInboundUuid: string | null;
                isDisabled: boolean;
                viewPosition: number;
                remark: string;
                isHidden: boolean;
                tag: string | null;
                vlessRouteId: number | null;
            };
            xrayJsonTemplate?: {
                [key: string]: unknown;
            } | null;
        }>;
    };
};

export type GetTemplatesResponseDto = {
    response: {
        total: number;
        templates: Array<{
            uuid: string;
            viewPosition: number;
            name: string;
            templateType: 'XRAY_JSON' | 'XRAY_BASE64' | 'MIHOMO' | 'STASH' | 'CLASH' | 'SINGBOX';
            templateJson: unknown;
            encodedTemplateYaml: string | null;
        }>;
    };
};

export type GetTemplateResponseDto = {
    response: {
        uuid: string;
        viewPosition: number;
        name: string;
        templateType: 'XRAY_JSON' | 'XRAY_BASE64' | 'MIHOMO' | 'STASH' | 'CLASH' | 'SINGBOX';
        templateJson: unknown;
        encodedTemplateYaml: string | null;
    };
};

export type UpdateTemplateRequestDto = {
    uuid: string;
    name?: string;
    templateJson?: {
        [key: string]: unknown;
    };
    encodedTemplateYaml?: string;
};

export type UpdateTemplateResponseDto = {
    response: {
        uuid: string;
        viewPosition: number;
        name: string;
        templateType: 'XRAY_JSON' | 'XRAY_BASE64' | 'MIHOMO' | 'STASH' | 'CLASH' | 'SINGBOX';
        templateJson: unknown;
        encodedTemplateYaml: string | null;
    };
};

export type DeleteSubscriptionTemplateResponseDto = {
    response: {
        isDeleted: boolean;
    };
};

export type CreateSubscriptionTemplateRequestDto = {
    name: string;
    templateType: 'XRAY_JSON' | 'XRAY_BASE64' | 'MIHOMO' | 'STASH' | 'CLASH' | 'SINGBOX';
};

export type CreateSubscriptionTemplateResponseDto = {
    response: {
        uuid: string;
        viewPosition: number;
        name: string;
        templateType: 'XRAY_JSON' | 'XRAY_BASE64' | 'MIHOMO' | 'STASH' | 'CLASH' | 'SINGBOX';
        templateJson: unknown;
        encodedTemplateYaml: string | null;
    };
};

export type ReorderSubscriptionTemplatesRequestDto = {
    items: Array<{
        viewPosition: number;
        uuid: string;
    }>;
};

export type ReorderSubscriptionTemplatesResponseDto = {
    response: {
        total: number;
        templates: Array<{
            uuid: string;
            viewPosition: number;
            name: string;
            templateType: 'XRAY_JSON' | 'XRAY_BASE64' | 'MIHOMO' | 'STASH' | 'CLASH' | 'SINGBOX';
            templateJson: unknown;
            encodedTemplateYaml: string | null;
        }>;
    };
};

export type CreateApiTokenRequestDto = {
    tokenName: string;
};

export type CreateApiTokenResponseDto = {
    response: {
        token: string;
        uuid: string;
    };
};

export type DeleteApiTokenResponseDto = {
    response: boolean;
};

export type FindAllApiTokensResponseDto = {
    response: {
        apiKeys: Array<{
            uuid: string;
            token: string;
            tokenName: string;
            createdAt: string;
            updatedAt: string;
        }>;
        docs: {
            isDocsEnabled: boolean;
            scalarPath: string | null;
            swaggerPath: string | null;
        };
    };
};

export type GetConfigProfilesResponseDto = {
    response: {
        total: number;
        configProfiles: Array<{
            uuid: string;
            viewPosition: number;
            name: string;
            config: unknown;
            inbounds: Array<{
                uuid: string;
                profileUuid: string;
                tag: string;
                type: string;
                network: string | null;
                security: string | null;
                port: number | null;
                rawInbound: unknown;
            }>;
            nodes: Array<{
                uuid: string;
                name: string;
                countryCode: string;
            }>;
            createdAt: string;
            updatedAt: string;
        }>;
    };
};

export type GetAllInboundsResponseDto = {
    response: {
        total: number;
        inbounds: Array<{
            uuid: string;
            profileUuid: string;
            tag: string;
            type: string;
            network: string | null;
            security: string | null;
            port: number | null;
            rawInbound: unknown;
            activeSquads: Array<string>;
        }>;
    };
};

export type GetInboundsByProfileUuidResponseDto = {
    response: {
        total: number;
        inbounds: Array<{
            uuid: string;
            profileUuid: string;
            tag: string;
            type: string;
            network: string | null;
            security: string | null;
            port: number | null;
            rawInbound: unknown;
            activeSquads: Array<string>;
        }>;
    };
};

export type GetConfigProfileByUuidResponseDto = {
    response: {
        uuid: string;
        viewPosition: number;
        name: string;
        config: unknown;
        inbounds: Array<{
            uuid: string;
            profileUuid: string;
            tag: string;
            type: string;
            network: string | null;
            security: string | null;
            port: number | null;
            rawInbound: unknown;
        }>;
        nodes: Array<{
            uuid: string;
            name: string;
            countryCode: string;
        }>;
        createdAt: string;
        updatedAt: string;
    };
};

export type GetComputedConfigProfileByUuidResponseDto = {
    response: {
        uuid: string;
        viewPosition: number;
        name: string;
        config: unknown;
        inbounds: Array<{
            uuid: string;
            profileUuid: string;
            tag: string;
            type: string;
            network: string | null;
            security: string | null;
            port: number | null;
            rawInbound: unknown;
        }>;
        nodes: Array<{
            uuid: string;
            name: string;
            countryCode: string;
        }>;
        createdAt: string;
        updatedAt: string;
    };
};

export type DeleteConfigProfileResponseDto = {
    response: {
        isDeleted: boolean;
    };
};

export type CreateConfigProfileRequestDto = {
    name: string;
    config: {
        [key: string]: unknown;
    };
};

export type CreateConfigProfileResponseDto = {
    response: {
        uuid: string;
        viewPosition: number;
        name: string;
        config: unknown;
        inbounds: Array<{
            uuid: string;
            profileUuid: string;
            tag: string;
            type: string;
            network: string | null;
            security: string | null;
            port: number | null;
            rawInbound: unknown;
        }>;
        nodes: Array<{
            uuid: string;
            name: string;
            countryCode: string;
        }>;
        createdAt: string;
        updatedAt: string;
    };
};

export type UpdateConfigProfileRequestDto = {
    uuid: string;
    name?: string;
    config?: {
        [key: string]: unknown;
    };
};

export type UpdateConfigProfileResponseDto = {
    response: {
        uuid: string;
        viewPosition: number;
        name: string;
        config: unknown;
        inbounds: Array<{
            uuid: string;
            profileUuid: string;
            tag: string;
            type: string;
            network: string | null;
            security: string | null;
            port: number | null;
            rawInbound: unknown;
        }>;
        nodes: Array<{
            uuid: string;
            name: string;
            countryCode: string;
        }>;
        createdAt: string;
        updatedAt: string;
    };
};

export type ReorderConfigProfilesRequestDto = {
    items: Array<{
        viewPosition: number;
        uuid: string;
    }>;
};

export type ReorderConfigProfilesResponseDto = {
    response: {
        total: number;
        configProfiles: Array<{
            uuid: string;
            viewPosition: number;
            name: string;
            config: unknown;
            inbounds: Array<{
                uuid: string;
                profileUuid: string;
                tag: string;
                type: string;
                network: string | null;
                security: string | null;
                port: number | null;
                rawInbound: unknown;
            }>;
            nodes: Array<{
                uuid: string;
                name: string;
                countryCode: string;
            }>;
            createdAt: string;
            updatedAt: string;
        }>;
    };
};

export type GetSnippetsResponseDto = {
    response: {
        total: number;
        snippets: Array<{
            name: string;
            snippet: unknown;
        }>;
    };
};

export type DeleteSnippetRequestDto = {
    name: string;
};

export type DeleteSnippetResponseDto = {
    response: {
        total: number;
        snippets: Array<{
            name: string;
            snippet: unknown;
        }>;
    };
};

export type CreateSnippetRequestDto = {
    name: string;
    snippet: Array<{
        [key: string]: unknown;
    }>;
};

export type CreateSnippetResponseDto = {
    response: {
        total: number;
        snippets: Array<{
            name: string;
            snippet: unknown;
        }>;
    };
};

export type UpdateSnippetRequestDto = {
    name: string;
    snippet: Array<{
        [key: string]: unknown;
    }>;
};

export type UpdateSnippetResponseDto = {
    response: {
        total: number;
        snippets: Array<{
            name: string;
            snippet: unknown;
        }>;
    };
};

export type GetInternalSquadsResponseDto = {
    response: {
        total: number;
        internalSquads: Array<{
            uuid: string;
            viewPosition: number;
            name: string;
            info: {
                membersCount: number;
                inboundsCount: number;
            };
            inbounds: Array<{
                uuid: string;
                profileUuid: string;
                tag: string;
                type: string;
                network: string | null;
                security: string | null;
                port: number | null;
                rawInbound: unknown;
            }>;
            createdAt: string;
            updatedAt: string;
        }>;
    };
};

export type GetInternalSquadByUuidResponseDto = {
    response: {
        uuid: string;
        viewPosition: number;
        name: string;
        info: {
            membersCount: number;
            inboundsCount: number;
        };
        inbounds: Array<{
            uuid: string;
            profileUuid: string;
            tag: string;
            type: string;
            network: string | null;
            security: string | null;
            port: number | null;
            rawInbound: unknown;
        }>;
        createdAt: string;
        updatedAt: string;
    };
};

export type CreateInternalSquadRequestDto = {
    name: string;
    inbounds: Array<string>;
};

export type CreateInternalSquadResponseDto = {
    response: {
        uuid: string;
        viewPosition: number;
        name: string;
        info: {
            membersCount: number;
            inboundsCount: number;
        };
        inbounds: Array<{
            uuid: string;
            profileUuid: string;
            tag: string;
            type: string;
            network: string | null;
            security: string | null;
            port: number | null;
            rawInbound: unknown;
        }>;
        createdAt: string;
        updatedAt: string;
    };
};

export type GetInternalSquadAccessibleNodesResponseDto = {
    response: {
        squadUuid: string;
        accessibleNodes: Array<{
            uuid: string;
            nodeName: string;
            countryCode: string;
            configProfileUuid: string;
            configProfileName: string;
            activeInbounds: Array<string>;
        }>;
    };
};

export type UpdateInternalSquadRequestDto = {
    uuid: string;
    name?: string;
    inbounds?: Array<string>;
};

export type UpdateInternalSquadResponseDto = {
    response: {
        uuid: string;
        viewPosition: number;
        name: string;
        info: {
            membersCount: number;
            inboundsCount: number;
        };
        inbounds: Array<{
            uuid: string;
            profileUuid: string;
            tag: string;
            type: string;
            network: string | null;
            security: string | null;
            port: number | null;
            rawInbound: unknown;
        }>;
        createdAt: string;
        updatedAt: string;
    };
};

export type DeleteInternalSquadResponseDto = {
    response: {
        isDeleted: boolean;
    };
};

export type AddUsersToInternalSquadResponseDto = {
    response: {
        eventSent: boolean;
    };
};

export type RemoveUsersFromInternalSquadResponseDto = {
    response: {
        eventSent: boolean;
    };
};

export type ReorderInternalSquadsRequestDto = {
    items: Array<{
        viewPosition: number;
        uuid: string;
    }>;
};

export type ReorderInternalSquadsResponseDto = {
    response: {
        total: number;
        internalSquads: Array<{
            uuid: string;
            viewPosition: number;
            name: string;
            info: {
                membersCount: number;
                inboundsCount: number;
            };
            inbounds: Array<{
                uuid: string;
                profileUuid: string;
                tag: string;
                type: string;
                network: string | null;
                security: string | null;
                port: number | null;
                rawInbound: unknown;
            }>;
            createdAt: string;
            updatedAt: string;
        }>;
    };
};

export type GetExternalSquadsResponseDto = {
    response: {
        total: number;
        externalSquads: Array<{
            uuid: string;
            viewPosition: number;
            name: string;
            info: {
                membersCount: number;
            };
            templates: Array<{
                templateUuid: string;
                templateType: 'XRAY_JSON' | 'XRAY_BASE64' | 'MIHOMO' | 'STASH' | 'CLASH' | 'SINGBOX';
            }>;
            subscriptionSettings: {
                profileTitle?: string;
                supportLink?: string;
                profileUpdateInterval?: number;
                isProfileWebpageUrlEnabled?: boolean;
                serveJsonAtBaseSubscription?: boolean;
                isShowCustomRemarks?: boolean;
                happAnnounce?: string | null;
                happRouting?: string | null;
                randomizeHosts?: boolean;
            } | null;
            hostOverrides: {
                serverDescription?: string | null;
                vlessRouteId?: number | null;
            } | null;
            responseHeaders: {
                [key: string]: string;
            } | null;
            hwidSettings: {
                enabled: boolean;
                fallbackDeviceLimit: number;
                maxDevicesAnnounce: string | null;
            } | null;
            customRemarks: {
                expiredUsers: Array<string>;
                limitedUsers: Array<string>;
                disabledUsers: Array<string>;
                emptyHosts: Array<string>;
                emptyInternalSquads: Array<string>;
            } | null;
            createdAt: string;
            updatedAt: string;
        }>;
    };
};

export type GetExternalSquadByUuidResponseDto = {
    response: {
        uuid: string;
        viewPosition: number;
        name: string;
        info: {
            membersCount: number;
        };
        templates: Array<{
            templateUuid: string;
            templateType: 'XRAY_JSON' | 'XRAY_BASE64' | 'MIHOMO' | 'STASH' | 'CLASH' | 'SINGBOX';
        }>;
        subscriptionSettings: {
            profileTitle?: string;
            supportLink?: string;
            profileUpdateInterval?: number;
            isProfileWebpageUrlEnabled?: boolean;
            serveJsonAtBaseSubscription?: boolean;
            isShowCustomRemarks?: boolean;
            happAnnounce?: string | null;
            happRouting?: string | null;
            randomizeHosts?: boolean;
        } | null;
        hostOverrides: {
            serverDescription?: string | null;
            vlessRouteId?: number | null;
        } | null;
        responseHeaders: {
            [key: string]: string;
        } | null;
        hwidSettings: {
            enabled: boolean;
            fallbackDeviceLimit: number;
            maxDevicesAnnounce: string | null;
        } | null;
        customRemarks: {
            expiredUsers: Array<string>;
            limitedUsers: Array<string>;
            disabledUsers: Array<string>;
            emptyHosts: Array<string>;
            emptyInternalSquads: Array<string>;
        } | null;
        createdAt: string;
        updatedAt: string;
    };
};

export type CreateExternalSquadRequestDto = {
    name: string;
};

export type CreateExternalSquadResponseDto = {
    response: {
        uuid: string;
        viewPosition: number;
        name: string;
        info: {
            membersCount: number;
        };
        templates: Array<{
            templateUuid: string;
            templateType: 'XRAY_JSON' | 'XRAY_BASE64' | 'MIHOMO' | 'STASH' | 'CLASH' | 'SINGBOX';
        }>;
        subscriptionSettings: {
            profileTitle?: string;
            supportLink?: string;
            profileUpdateInterval?: number;
            isProfileWebpageUrlEnabled?: boolean;
            serveJsonAtBaseSubscription?: boolean;
            isShowCustomRemarks?: boolean;
            happAnnounce?: string | null;
            happRouting?: string | null;
            randomizeHosts?: boolean;
        } | null;
        hostOverrides: {
            serverDescription?: string | null;
            vlessRouteId?: number | null;
        } | null;
        responseHeaders: {
            [key: string]: string;
        } | null;
        hwidSettings: {
            enabled: boolean;
            fallbackDeviceLimit: number;
            maxDevicesAnnounce: string | null;
        } | null;
        customRemarks: {
            expiredUsers: Array<string>;
            limitedUsers: Array<string>;
            disabledUsers: Array<string>;
            emptyHosts: Array<string>;
            emptyInternalSquads: Array<string>;
        } | null;
        createdAt: string;
        updatedAt: string;
    };
};

export type UpdateExternalSquadRequestDto = {
    uuid: string;
    name?: string;
    templates?: Array<{
        templateUuid: string;
        templateType: 'XRAY_JSON' | 'XRAY_BASE64' | 'MIHOMO' | 'STASH' | 'CLASH' | 'SINGBOX';
    }>;
    subscriptionSettings?: {
        profileTitle?: string;
        supportLink?: string;
        profileUpdateInterval?: number;
        isProfileWebpageUrlEnabled?: boolean;
        serveJsonAtBaseSubscription?: boolean;
        isShowCustomRemarks?: boolean;
        happAnnounce?: string | null;
        happRouting?: string | null;
        randomizeHosts?: boolean;
    };
    hostOverrides?: {
        serverDescription?: string | null;
        vlessRouteId?: number | null;
    };
    responseHeaders?: {
        [key: string]: string;
    } | null;
    hwidSettings?: {
        enabled: boolean;
        fallbackDeviceLimit: number;
        maxDevicesAnnounce: string | null;
    } | null;
    customRemarks?: {
        expiredUsers: Array<string>;
        limitedUsers: Array<string>;
        disabledUsers: Array<string>;
        emptyHosts: Array<string>;
        emptyInternalSquads: Array<string>;
    } | null;
};

export type UpdateExternalSquadResponseDto = {
    response: {
        uuid: string;
        viewPosition: number;
        name: string;
        info: {
            membersCount: number;
        };
        templates: Array<{
            templateUuid: string;
            templateType: 'XRAY_JSON' | 'XRAY_BASE64' | 'MIHOMO' | 'STASH' | 'CLASH' | 'SINGBOX';
        }>;
        subscriptionSettings: {
            profileTitle?: string;
            supportLink?: string;
            profileUpdateInterval?: number;
            isProfileWebpageUrlEnabled?: boolean;
            serveJsonAtBaseSubscription?: boolean;
            isShowCustomRemarks?: boolean;
            happAnnounce?: string | null;
            happRouting?: string | null;
            randomizeHosts?: boolean;
        } | null;
        hostOverrides: {
            serverDescription?: string | null;
            vlessRouteId?: number | null;
        } | null;
        responseHeaders: {
            [key: string]: string;
        } | null;
        hwidSettings: {
            enabled: boolean;
            fallbackDeviceLimit: number;
            maxDevicesAnnounce: string | null;
        } | null;
        customRemarks: {
            expiredUsers: Array<string>;
            limitedUsers: Array<string>;
            disabledUsers: Array<string>;
            emptyHosts: Array<string>;
            emptyInternalSquads: Array<string>;
        } | null;
        createdAt: string;
        updatedAt: string;
    };
};

export type DeleteExternalSquadResponseDto = {
    response: {
        isDeleted: boolean;
    };
};

export type AddUsersToExternalSquadResponseDto = {
    response: {
        eventSent: boolean;
    };
};

export type RemoveUsersFromExternalSquadResponseDto = {
    response: {
        eventSent: boolean;
    };
};

export type ReorderExternalSquadsRequestDto = {
    items: Array<{
        viewPosition: number;
        uuid: string;
    }>;
};

export type ReorderExternalSquadsResponseDto = {
    response: {
        total: number;
        externalSquads: Array<{
            uuid: string;
            viewPosition: number;
            name: string;
            info: {
                membersCount: number;
            };
            templates: Array<{
                templateUuid: string;
                templateType: 'XRAY_JSON' | 'XRAY_BASE64' | 'MIHOMO' | 'STASH' | 'CLASH' | 'SINGBOX';
            }>;
            subscriptionSettings: {
                profileTitle?: string;
                supportLink?: string;
                profileUpdateInterval?: number;
                isProfileWebpageUrlEnabled?: boolean;
                serveJsonAtBaseSubscription?: boolean;
                isShowCustomRemarks?: boolean;
                happAnnounce?: string | null;
                happRouting?: string | null;
                randomizeHosts?: boolean;
            } | null;
            hostOverrides: {
                serverDescription?: string | null;
                vlessRouteId?: number | null;
            } | null;
            responseHeaders: {
                [key: string]: string;
            } | null;
            hwidSettings: {
                enabled: boolean;
                fallbackDeviceLimit: number;
                maxDevicesAnnounce: string | null;
            } | null;
            customRemarks: {
                expiredUsers: Array<string>;
                limitedUsers: Array<string>;
                disabledUsers: Array<string>;
                emptyHosts: Array<string>;
                emptyInternalSquads: Array<string>;
            } | null;
            createdAt: string;
            updatedAt: string;
        }>;
    };
};

export type GetPubKeyResponseDto = {
    response: {
        pubKey: string;
    };
};

export type GetAllNodesTagsResponseDto = {
    response: {
        tags: Array<string>;
    };
};

export type CreateNodeRequestDto = {
    name: string;
    address: string;
    port?: number;
    isTrafficTrackingActive?: boolean;
    trafficLimitBytes?: number;
    notifyPercent?: number;
    trafficResetDay?: number;
    countryCode?: string;
    consumptionMultiplier?: number;
    configProfile: {
        activeConfigProfileUuid: string;
        activeInbounds: Array<string>;
    };
    providerUuid?: string | null;
    tags?: Array<string>;
};

export type CreateNodeResponseDto = {
    response: {
        uuid: string;
        name: string;
        address: string;
        port: number | null;
        isConnected: boolean;
        isDisabled: boolean;
        isConnecting: boolean;
        lastStatusChange: string | null;
        lastStatusMessage: string | null;
        xrayVersion: string | null;
        nodeVersion: string | null;
        xrayUptime: string;
        isTrafficTrackingActive: boolean;
        trafficResetDay: number | null;
        trafficLimitBytes: number | null;
        trafficUsedBytes: number | null;
        notifyPercent: number | null;
        usersOnline: number | null;
        viewPosition: number;
        countryCode: string;
        consumptionMultiplier: number;
        tags: Array<string>;
        cpuCount: number | null;
        cpuModel: string | null;
        totalRam: string | null;
        createdAt: string;
        updatedAt: string;
        configProfile: {
            activeConfigProfileUuid: string | null;
            activeInbounds: Array<{
                uuid: string;
                profileUuid: string;
                tag: string;
                type: string;
                network: string | null;
                security: string | null;
                port: number | null;
                rawInbound: unknown;
            }>;
        };
        providerUuid: string | null;
        provider: {
            uuid: string;
            name: string;
            faviconLink: string | null;
            loginUrl: string | null;
            createdAt: string;
            updatedAt: string;
        } | null;
    };
};

export type GetAllNodesResponseDto = {
    response: Array<{
        uuid: string;
        name: string;
        address: string;
        port: number | null;
        isConnected: boolean;
        isDisabled: boolean;
        isConnecting: boolean;
        lastStatusChange: string | null;
        lastStatusMessage: string | null;
        xrayVersion: string | null;
        nodeVersion: string | null;
        xrayUptime: string;
        isTrafficTrackingActive: boolean;
        trafficResetDay: number | null;
        trafficLimitBytes: number | null;
        trafficUsedBytes: number | null;
        notifyPercent: number | null;
        usersOnline: number | null;
        viewPosition: number;
        countryCode: string;
        consumptionMultiplier: number;
        tags: Array<string>;
        cpuCount: number | null;
        cpuModel: string | null;
        totalRam: string | null;
        createdAt: string;
        updatedAt: string;
        configProfile: {
            activeConfigProfileUuid: string | null;
            activeInbounds: Array<{
                uuid: string;
                profileUuid: string;
                tag: string;
                type: string;
                network: string | null;
                security: string | null;
                port: number | null;
                rawInbound: unknown;
            }>;
        };
        providerUuid: string | null;
        provider: {
            uuid: string;
            name: string;
            faviconLink: string | null;
            loginUrl: string | null;
            createdAt: string;
            updatedAt: string;
        } | null;
    }>;
};

export type GetOneNodeResponseDto = {
    response: {
        uuid: string;
        name: string;
        address: string;
        port: number | null;
        isConnected: boolean;
        isDisabled: boolean;
        isConnecting: boolean;
        lastStatusChange: string | null;
        lastStatusMessage: string | null;
        xrayVersion: string | null;
        nodeVersion: string | null;
        xrayUptime: string;
        isTrafficTrackingActive: boolean;
        trafficResetDay: number | null;
        trafficLimitBytes: number | null;
        trafficUsedBytes: number | null;
        notifyPercent: number | null;
        usersOnline: number | null;
        viewPosition: number;
        countryCode: string;
        consumptionMultiplier: number;
        tags: Array<string>;
        cpuCount: number | null;
        cpuModel: string | null;
        totalRam: string | null;
        createdAt: string;
        updatedAt: string;
        configProfile: {
            activeConfigProfileUuid: string | null;
            activeInbounds: Array<{
                uuid: string;
                profileUuid: string;
                tag: string;
                type: string;
                network: string | null;
                security: string | null;
                port: number | null;
                rawInbound: unknown;
            }>;
        };
        providerUuid: string | null;
        provider: {
            uuid: string;
            name: string;
            faviconLink: string | null;
            loginUrl: string | null;
            createdAt: string;
            updatedAt: string;
        } | null;
    };
};

export type EnableNodeResponseDto = {
    response: {
        uuid: string;
        name: string;
        address: string;
        port: number | null;
        isConnected: boolean;
        isDisabled: boolean;
        isConnecting: boolean;
        lastStatusChange: string | null;
        lastStatusMessage: string | null;
        xrayVersion: string | null;
        nodeVersion: string | null;
        xrayUptime: string;
        isTrafficTrackingActive: boolean;
        trafficResetDay: number | null;
        trafficLimitBytes: number | null;
        trafficUsedBytes: number | null;
        notifyPercent: number | null;
        usersOnline: number | null;
        viewPosition: number;
        countryCode: string;
        consumptionMultiplier: number;
        tags: Array<string>;
        cpuCount: number | null;
        cpuModel: string | null;
        totalRam: string | null;
        createdAt: string;
        updatedAt: string;
        configProfile: {
            activeConfigProfileUuid: string | null;
            activeInbounds: Array<{
                uuid: string;
                profileUuid: string;
                tag: string;
                type: string;
                network: string | null;
                security: string | null;
                port: number | null;
                rawInbound: unknown;
            }>;
        };
        providerUuid: string | null;
        provider: {
            uuid: string;
            name: string;
            faviconLink: string | null;
            loginUrl: string | null;
            createdAt: string;
            updatedAt: string;
        } | null;
    };
};

export type DisableNodeResponseDto = {
    response: {
        uuid: string;
        name: string;
        address: string;
        port: number | null;
        isConnected: boolean;
        isDisabled: boolean;
        isConnecting: boolean;
        lastStatusChange: string | null;
        lastStatusMessage: string | null;
        xrayVersion: string | null;
        nodeVersion: string | null;
        xrayUptime: string;
        isTrafficTrackingActive: boolean;
        trafficResetDay: number | null;
        trafficLimitBytes: number | null;
        trafficUsedBytes: number | null;
        notifyPercent: number | null;
        usersOnline: number | null;
        viewPosition: number;
        countryCode: string;
        consumptionMultiplier: number;
        tags: Array<string>;
        cpuCount: number | null;
        cpuModel: string | null;
        totalRam: string | null;
        createdAt: string;
        updatedAt: string;
        configProfile: {
            activeConfigProfileUuid: string | null;
            activeInbounds: Array<{
                uuid: string;
                profileUuid: string;
                tag: string;
                type: string;
                network: string | null;
                security: string | null;
                port: number | null;
                rawInbound: unknown;
            }>;
        };
        providerUuid: string | null;
        provider: {
            uuid: string;
            name: string;
            faviconLink: string | null;
            loginUrl: string | null;
            createdAt: string;
            updatedAt: string;
        } | null;
    };
};

export type DeleteNodeResponseDto = {
    response: {
        isDeleted: boolean;
    };
};

export type UpdateNodeRequestDto = {
    uuid: string;
    name?: string;
    address?: string;
    port?: number;
    isTrafficTrackingActive?: boolean;
    trafficLimitBytes?: number;
    notifyPercent?: number;
    trafficResetDay?: number;
    countryCode?: string;
    consumptionMultiplier?: number;
    configProfile?: {
        activeConfigProfileUuid: string;
        activeInbounds: Array<string>;
    };
    providerUuid?: string | null;
    tags?: Array<string>;
};

export type UpdateNodeResponseDto = {
    response: {
        uuid: string;
        name: string;
        address: string;
        port: number | null;
        isConnected: boolean;
        isDisabled: boolean;
        isConnecting: boolean;
        lastStatusChange: string | null;
        lastStatusMessage: string | null;
        xrayVersion: string | null;
        nodeVersion: string | null;
        xrayUptime: string;
        isTrafficTrackingActive: boolean;
        trafficResetDay: number | null;
        trafficLimitBytes: number | null;
        trafficUsedBytes: number | null;
        notifyPercent: number | null;
        usersOnline: number | null;
        viewPosition: number;
        countryCode: string;
        consumptionMultiplier: number;
        tags: Array<string>;
        cpuCount: number | null;
        cpuModel: string | null;
        totalRam: string | null;
        createdAt: string;
        updatedAt: string;
        configProfile: {
            activeConfigProfileUuid: string | null;
            activeInbounds: Array<{
                uuid: string;
                profileUuid: string;
                tag: string;
                type: string;
                network: string | null;
                security: string | null;
                port: number | null;
                rawInbound: unknown;
            }>;
        };
        providerUuid: string | null;
        provider: {
            uuid: string;
            name: string;
            faviconLink: string | null;
            loginUrl: string | null;
            createdAt: string;
            updatedAt: string;
        } | null;
    };
};

export type RestartNodeResponseDto = {
    response: {
        eventSent: boolean;
    };
};

export type ResetNodeTrafficResponseDto = {
    response: {
        eventSent: boolean;
    };
};

export type RestartAllNodesRequestBodyDto = {
    forceRestart?: boolean;
};

export type RestartAllNodesResponseDto = {
    response: {
        eventSent: boolean;
    };
};

export type ReorderNodeRequestDto = {
    nodes: Array<{
        viewPosition: number;
        uuid: string;
    }>;
};

export type ReorderNodeResponseDto = {
    response: Array<{
        uuid: string;
        name: string;
        address: string;
        port: number | null;
        isConnected: boolean;
        isDisabled: boolean;
        isConnecting: boolean;
        lastStatusChange: string | null;
        lastStatusMessage: string | null;
        xrayVersion: string | null;
        nodeVersion: string | null;
        xrayUptime: string;
        isTrafficTrackingActive: boolean;
        trafficResetDay: number | null;
        trafficLimitBytes: number | null;
        trafficUsedBytes: number | null;
        notifyPercent: number | null;
        usersOnline: number | null;
        viewPosition: number;
        countryCode: string;
        consumptionMultiplier: number;
        tags: Array<string>;
        cpuCount: number | null;
        cpuModel: string | null;
        totalRam: string | null;
        createdAt: string;
        updatedAt: string;
        configProfile: {
            activeConfigProfileUuid: string | null;
            activeInbounds: Array<{
                uuid: string;
                profileUuid: string;
                tag: string;
                type: string;
                network: string | null;
                security: string | null;
                port: number | null;
                rawInbound: unknown;
            }>;
        };
        providerUuid: string | null;
        provider: {
            uuid: string;
            name: string;
            faviconLink: string | null;
            loginUrl: string | null;
            createdAt: string;
            updatedAt: string;
        } | null;
    }>;
};

export type ProfileModificationRequestDto = {
    uuids: Array<string>;
    configProfile: {
        activeConfigProfileUuid: string;
        activeInbounds: Array<string>;
    };
};

export type ProfileModificationResponseDto = {
    response: {
        eventSent: boolean;
    };
};

export type GetAllHostTagsResponseDto = {
    response: {
        tags: Array<string>;
    };
};

export type CreateHostRequestDto = {
    inbound: {
        configProfileUuid: string;
        configProfileInboundUuid: string;
    };
    remark: string;
    address: string;
    port: number;
    path?: string;
    sni?: string;
    host?: string;
    alpn?: 'h3' | 'h2' | 'http/1.1' | 'h2,http/1.1' | 'h3,h2,http/1.1' | 'h3,h2';
    fingerprint?: 'chrome' | 'firefox' | 'safari' | 'ios' | 'android' | 'edge' | 'qq' | 'random' | 'randomized';
    isDisabled?: boolean;
    securityLayer?: 'DEFAULT' | 'TLS' | 'NONE';
    xHttpExtraParams?: unknown;
    muxParams?: unknown;
    sockoptParams?: unknown;
    serverDescription?: string | null;
    /**
     * Optional. Host tag for categorization. Max 32 characters, uppercase letters, numbers, underscores and colons are allowed.
     */
    tag?: string | null;
    isHidden?: boolean;
    overrideSniFromAddress?: boolean;
    keepSniBlank?: boolean;
    allowInsecure?: boolean;
    vlessRouteId?: number | null;
    shuffleHost?: boolean;
    mihomoX25519?: boolean;
    nodes?: Array<string>;
    xrayJsonTemplateUuid?: string | null;
    /**
     * Optional. Internal squads from which the host will be excluded.
     */
    excludedInternalSquads?: Array<string>;
};

export type CreateHostResponseDto = {
    response: {
        uuid: string;
        viewPosition: number;
        remark: string;
        address: string;
        port: number;
        path: string | null;
        sni: string | null;
        host: string | null;
        alpn: string | null;
        fingerprint: string | null;
        isDisabled?: boolean;
        securityLayer?: 'DEFAULT' | 'TLS' | 'NONE';
        xHttpExtraParams: unknown;
        muxParams: unknown;
        sockoptParams: unknown;
        inbound: {
            configProfileUuid: string | null;
            configProfileInboundUuid: string | null;
        };
        serverDescription: string | null;
        tag: string | null;
        isHidden?: boolean;
        overrideSniFromAddress?: boolean;
        keepSniBlank?: boolean;
        vlessRouteId: number | null;
        allowInsecure?: boolean;
        shuffleHost: boolean;
        mihomoX25519: boolean;
        nodes: Array<string>;
        xrayJsonTemplateUuid: string | null;
        excludedInternalSquads: Array<string>;
    };
};

export type UpdateHostRequestDto = {
    uuid: string;
    inbound?: {
        configProfileUuid: string;
        configProfileInboundUuid: string;
    };
    remark?: string;
    address?: string;
    port?: number;
    path?: string;
    sni?: string;
    host?: string;
    alpn?: 'h3' | 'h2' | 'http/1.1' | 'h2,http/1.1' | 'h3,h2,http/1.1' | 'h3,h2';
    fingerprint?: 'chrome' | 'firefox' | 'safari' | 'ios' | 'android' | 'edge' | 'qq' | 'random' | 'randomized';
    isDisabled?: boolean;
    securityLayer?: 'DEFAULT' | 'TLS' | 'NONE';
    xHttpExtraParams?: unknown;
    muxParams?: unknown;
    sockoptParams?: unknown;
    serverDescription?: string | null;
    /**
     * Optional. Host tag for categorization. Max 32 characters, uppercase letters, numbers, underscores and colons are allowed.
     */
    tag?: string | null;
    isHidden?: boolean;
    overrideSniFromAddress?: boolean;
    keepSniBlank?: boolean;
    vlessRouteId?: number | null;
    allowInsecure?: boolean;
    shuffleHost?: boolean;
    mihomoX25519?: boolean;
    nodes?: Array<string>;
    xrayJsonTemplateUuid?: string | null;
    /**
     * Optional. Internal squads from which the host will be excluded.
     */
    excludedInternalSquads?: Array<string>;
};

export type UpdateHostResponseDto = {
    response: {
        uuid: string;
        viewPosition: number;
        remark: string;
        address: string;
        port: number;
        path: string | null;
        sni: string | null;
        host: string | null;
        alpn: string | null;
        fingerprint: string | null;
        isDisabled?: boolean;
        securityLayer?: 'DEFAULT' | 'TLS' | 'NONE';
        xHttpExtraParams: unknown;
        muxParams: unknown;
        sockoptParams: unknown;
        inbound: {
            configProfileUuid: string | null;
            configProfileInboundUuid: string | null;
        };
        serverDescription: string | null;
        tag: string | null;
        isHidden?: boolean;
        overrideSniFromAddress?: boolean;
        keepSniBlank?: boolean;
        vlessRouteId: number | null;
        allowInsecure?: boolean;
        shuffleHost: boolean;
        mihomoX25519: boolean;
        nodes: Array<string>;
        xrayJsonTemplateUuid: string | null;
        excludedInternalSquads: Array<string>;
    };
};

export type GetAllHostsResponseDto = {
    response: Array<{
        uuid: string;
        viewPosition: number;
        remark: string;
        address: string;
        port: number;
        path: string | null;
        sni: string | null;
        host: string | null;
        alpn: string | null;
        fingerprint: string | null;
        isDisabled?: boolean;
        securityLayer?: 'DEFAULT' | 'TLS' | 'NONE';
        xHttpExtraParams: unknown;
        muxParams: unknown;
        sockoptParams: unknown;
        inbound: {
            configProfileUuid: string | null;
            configProfileInboundUuid: string | null;
        };
        serverDescription: string | null;
        tag: string | null;
        isHidden?: boolean;
        overrideSniFromAddress?: boolean;
        keepSniBlank?: boolean;
        vlessRouteId: number | null;
        allowInsecure?: boolean;
        shuffleHost: boolean;
        mihomoX25519: boolean;
        nodes: Array<string>;
        xrayJsonTemplateUuid: string | null;
        excludedInternalSquads: Array<string>;
    }>;
};

export type GetOneHostResponseDto = {
    response: {
        uuid: string;
        viewPosition: number;
        remark: string;
        address: string;
        port: number;
        path: string | null;
        sni: string | null;
        host: string | null;
        alpn: string | null;
        fingerprint: string | null;
        isDisabled?: boolean;
        securityLayer?: 'DEFAULT' | 'TLS' | 'NONE';
        xHttpExtraParams: unknown;
        muxParams: unknown;
        sockoptParams: unknown;
        inbound: {
            configProfileUuid: string | null;
            configProfileInboundUuid: string | null;
        };
        serverDescription: string | null;
        tag: string | null;
        isHidden?: boolean;
        overrideSniFromAddress?: boolean;
        keepSniBlank?: boolean;
        vlessRouteId: number | null;
        allowInsecure?: boolean;
        shuffleHost: boolean;
        mihomoX25519: boolean;
        nodes: Array<string>;
        xrayJsonTemplateUuid: string | null;
        excludedInternalSquads: Array<string>;
    };
};

export type ReorderHostRequestDto = {
    hosts: Array<{
        viewPosition: number;
        uuid: string;
    }>;
};

export type ReorderHostResponseDto = {
    response: {
        isUpdated: boolean;
    };
};

export type DeleteHostResponseDto = {
    response: {
        isDeleted: boolean;
    };
};

export type BulkDeleteHostsRequestDto = {
    uuids: Array<string>;
};

export type BulkDeleteHostsResponseDto = {
    response: Array<{
        uuid: string;
        viewPosition: number;
        remark: string;
        address: string;
        port: number;
        path: string | null;
        sni: string | null;
        host: string | null;
        alpn: string | null;
        fingerprint: string | null;
        isDisabled?: boolean;
        securityLayer?: 'DEFAULT' | 'TLS' | 'NONE';
        xHttpExtraParams: unknown;
        muxParams: unknown;
        sockoptParams: unknown;
        inbound: {
            configProfileUuid: string | null;
            configProfileInboundUuid: string | null;
        };
        serverDescription: string | null;
        tag: string | null;
        isHidden?: boolean;
        overrideSniFromAddress?: boolean;
        keepSniBlank?: boolean;
        vlessRouteId: number | null;
        allowInsecure?: boolean;
        shuffleHost: boolean;
        mihomoX25519: boolean;
        nodes: Array<string>;
        xrayJsonTemplateUuid: string | null;
        excludedInternalSquads: Array<string>;
    }>;
};

export type BulkDisableHostsRequestDto = {
    uuids: Array<string>;
};

export type BulkDisableHostsResponseDto = {
    response: Array<{
        uuid: string;
        viewPosition: number;
        remark: string;
        address: string;
        port: number;
        path: string | null;
        sni: string | null;
        host: string | null;
        alpn: string | null;
        fingerprint: string | null;
        isDisabled?: boolean;
        securityLayer?: 'DEFAULT' | 'TLS' | 'NONE';
        xHttpExtraParams: unknown;
        muxParams: unknown;
        sockoptParams: unknown;
        inbound: {
            configProfileUuid: string | null;
            configProfileInboundUuid: string | null;
        };
        serverDescription: string | null;
        tag: string | null;
        isHidden?: boolean;
        overrideSniFromAddress?: boolean;
        keepSniBlank?: boolean;
        vlessRouteId: number | null;
        allowInsecure?: boolean;
        shuffleHost: boolean;
        mihomoX25519: boolean;
        nodes: Array<string>;
        xrayJsonTemplateUuid: string | null;
        excludedInternalSquads: Array<string>;
    }>;
};

export type BulkEnableHostsRequestDto = {
    uuids: Array<string>;
};

export type BulkEnableHostsResponseDto = {
    response: Array<{
        uuid: string;
        viewPosition: number;
        remark: string;
        address: string;
        port: number;
        path: string | null;
        sni: string | null;
        host: string | null;
        alpn: string | null;
        fingerprint: string | null;
        isDisabled?: boolean;
        securityLayer?: 'DEFAULT' | 'TLS' | 'NONE';
        xHttpExtraParams: unknown;
        muxParams: unknown;
        sockoptParams: unknown;
        inbound: {
            configProfileUuid: string | null;
            configProfileInboundUuid: string | null;
        };
        serverDescription: string | null;
        tag: string | null;
        isHidden?: boolean;
        overrideSniFromAddress?: boolean;
        keepSniBlank?: boolean;
        vlessRouteId: number | null;
        allowInsecure?: boolean;
        shuffleHost: boolean;
        mihomoX25519: boolean;
        nodes: Array<string>;
        xrayJsonTemplateUuid: string | null;
        excludedInternalSquads: Array<string>;
    }>;
};

export type SetInboundToManyHostsRequestDto = {
    uuids: Array<string>;
    configProfileUuid: string;
    configProfileInboundUuid: string;
};

export type SetInboundToManyHostsResponseDto = {
    response: Array<{
        uuid: string;
        viewPosition: number;
        remark: string;
        address: string;
        port: number;
        path: string | null;
        sni: string | null;
        host: string | null;
        alpn: string | null;
        fingerprint: string | null;
        isDisabled?: boolean;
        securityLayer?: 'DEFAULT' | 'TLS' | 'NONE';
        xHttpExtraParams: unknown;
        muxParams: unknown;
        sockoptParams: unknown;
        inbound: {
            configProfileUuid: string | null;
            configProfileInboundUuid: string | null;
        };
        serverDescription: string | null;
        tag: string | null;
        isHidden?: boolean;
        overrideSniFromAddress?: boolean;
        keepSniBlank?: boolean;
        vlessRouteId: number | null;
        allowInsecure?: boolean;
        shuffleHost: boolean;
        mihomoX25519: boolean;
        nodes: Array<string>;
        xrayJsonTemplateUuid: string | null;
        excludedInternalSquads: Array<string>;
    }>;
};

export type SetPortToManyHostsRequestDto = {
    uuids: Array<string>;
    port: number;
};

export type SetPortToManyHostsResponseDto = {
    response: Array<{
        uuid: string;
        viewPosition: number;
        remark: string;
        address: string;
        port: number;
        path: string | null;
        sni: string | null;
        host: string | null;
        alpn: string | null;
        fingerprint: string | null;
        isDisabled?: boolean;
        securityLayer?: 'DEFAULT' | 'TLS' | 'NONE';
        xHttpExtraParams: unknown;
        muxParams: unknown;
        sockoptParams: unknown;
        inbound: {
            configProfileUuid: string | null;
            configProfileInboundUuid: string | null;
        };
        serverDescription: string | null;
        tag: string | null;
        isHidden?: boolean;
        overrideSniFromAddress?: boolean;
        keepSniBlank?: boolean;
        vlessRouteId: number | null;
        allowInsecure?: boolean;
        shuffleHost: boolean;
        mihomoX25519: boolean;
        nodes: Array<string>;
        xrayJsonTemplateUuid: string | null;
        excludedInternalSquads: Array<string>;
    }>;
};

export type GetNodeUserUsageByRangeResponseDto = {
    response: Array<{
        userUuid: string;
        username: string;
        nodeUuid: string;
        total: number;
        date: string;
    }>;
};

export type GetNodesRealtimeUsageResponseDto = {
    response: Array<{
        nodeUuid: string;
        nodeName: string;
        countryCode: string;
        downloadBytes: number;
        uploadBytes: number;
        totalBytes: number;
        downloadSpeedBps: number;
        uploadSpeedBps: number;
        totalSpeedBps: number;
    }>;
};

export type GetAllHwidDevicesResponseDto = {
    response: {
        devices: Array<{
            hwid: string;
            userUuid: string;
            platform: string | null;
            osVersion: string | null;
            deviceModel: string | null;
            userAgent: string | null;
            createdAt: string;
            updatedAt: string;
        }>;
        total: number;
    };
};

export type CreateUserHwidDeviceRequestDto = {
    hwid: string;
    userUuid: string;
    platform?: string;
    osVersion?: string;
    deviceModel?: string;
    userAgent?: string;
};

export type CreateUserHwidDeviceResponseDto = {
    response: {
        total: number;
        devices: Array<{
            hwid: string;
            userUuid: string;
            platform: string | null;
            osVersion: string | null;
            deviceModel: string | null;
            userAgent: string | null;
            createdAt: string;
            updatedAt: string;
        }>;
    };
};

export type DeleteUserHwidDeviceRequestDto = {
    userUuid: string;
    hwid: string;
};

export type DeleteUserHwidDeviceResponseDto = {
    response: {
        total: number;
        devices: Array<{
            hwid: string;
            userUuid: string;
            platform: string | null;
            osVersion: string | null;
            deviceModel: string | null;
            userAgent: string | null;
            createdAt: string;
            updatedAt: string;
        }>;
    };
};

export type DeleteAllUserHwidDevicesRequestDto = {
    userUuid: string;
};

export type DeleteAllUserHwidDevicesResponseDto = {
    response: {
        total: number;
        devices: Array<{
            hwid: string;
            userUuid: string;
            platform: string | null;
            osVersion: string | null;
            deviceModel: string | null;
            userAgent: string | null;
            createdAt: string;
            updatedAt: string;
        }>;
    };
};

export type GetHwidDevicesStatsResponseDto = {
    response: {
        byPlatform: Array<{
            platform: string;
            count: number;
        }>;
        byApp: Array<{
            app: string;
            count: number;
        }>;
        stats: {
            totalUniqueDevices: number;
            totalHwidDevices: number;
            averageHwidDevicesPerUser: number;
        };
    };
};

export type GetTopUsersByHwidDevicesResponseDto = {
    response: {
        users: Array<{
            userUuid: string;
            id: number;
            username: string;
            devicesCount: number;
        }>;
        total: number;
    };
};

export type GetUserHwidDevicesResponseDto = {
    response: {
        total: number;
        devices: Array<{
            hwid: string;
            userUuid: string;
            platform: string | null;
            osVersion: string | null;
            deviceModel: string | null;
            userAgent: string | null;
            createdAt: string;
            updatedAt: string;
        }>;
    };
};

export type GetNodesUsageByRangeResponseDto = {
    response: Array<{
        nodeUuid: string;
        nodeName: string;
        nodeCountryCode: string;
        total: number;
        totalDownload: number;
        totalUpload: number;
        humanReadableTotal: string;
        humanReadableTotalDownload: string;
        humanReadableTotalUpload: string;
        date: string;
    }>;
};

export type GetInfraProvidersResponseDto = {
    response: {
        total: number;
        providers: Array<{
            uuid: string;
            name: string;
            faviconLink: string | null;
            loginUrl: string | null;
            createdAt: string;
            updatedAt: string;
            billingHistory: {
                totalAmount: number;
                totalBills: number;
            };
            billingNodes: Array<{
                nodeUuid: string;
                name: string;
                countryCode: string;
            }>;
        }>;
    };
};

export type GetInfraProviderByUuidResponseDto = {
    response: {
        uuid: string;
        name: string;
        faviconLink: string | null;
        loginUrl: string | null;
        createdAt: string;
        updatedAt: string;
        billingHistory: {
            totalAmount: number;
            totalBills: number;
        };
        billingNodes: Array<{
            nodeUuid: string;
            name: string;
            countryCode: string;
        }>;
    };
};

export type DeleteInfraProviderByUuidResponseDto = {
    response: {
        isDeleted: boolean;
    };
};

export type CreateInfraProviderRequestDto = {
    name: string;
    faviconLink?: string;
    loginUrl?: string;
};

export type CreateInfraProviderResponseDto = {
    response: {
        uuid: string;
        name: string;
        faviconLink: string | null;
        loginUrl: string | null;
        createdAt: string;
        updatedAt: string;
        billingHistory: {
            totalAmount: number;
            totalBills: number;
        };
        billingNodes: Array<{
            nodeUuid: string;
            name: string;
            countryCode: string;
        }>;
    };
};

export type UpdateInfraProviderRequestDto = {
    uuid: string;
    name?: string;
    faviconLink?: string | null;
    loginUrl?: string | null;
};

export type UpdateInfraProviderResponseDto = {
    response: {
        uuid: string;
        name: string;
        faviconLink: string | null;
        loginUrl: string | null;
        createdAt: string;
        updatedAt: string;
        billingHistory: {
            totalAmount: number;
            totalBills: number;
        };
        billingNodes: Array<{
            nodeUuid: string;
            name: string;
            countryCode: string;
        }>;
    };
};

export type CreateInfraBillingHistoryRecordRequestDto = {
    providerUuid: string;
    amount: number;
    /**
     * Billing date. Format: 2025-01-17T15:38:45.065Z
     */
    billedAt: string;
};

export type CreateInfraBillingHistoryRecordResponseDto = {
    response: {
        records: Array<{
            uuid: string;
            providerUuid: string;
            amount: number;
            billedAt: string;
            provider: {
                uuid: string;
                name: string;
                faviconLink: string | null;
            };
        }>;
        total: number;
    };
};

export type GetInfraBillingHistoryRecordsResponseDto = {
    response: {
        records: Array<{
            uuid: string;
            providerUuid: string;
            amount: number;
            billedAt: string;
            provider: {
                uuid: string;
                name: string;
                faviconLink: string | null;
            };
        }>;
        total: number;
    };
};

export type DeleteInfraBillingHistoryRecordByUuidResponseDto = {
    response: {
        records: Array<{
            uuid: string;
            providerUuid: string;
            amount: number;
            billedAt: string;
            provider: {
                uuid: string;
                name: string;
                faviconLink: string | null;
            };
        }>;
        total: number;
    };
};

export type GetInfraBillingNodesResponseDto = {
    response: {
        totalBillingNodes: number;
        billingNodes: Array<{
            uuid: string;
            nodeUuid: string;
            providerUuid: string;
            provider: {
                uuid: string;
                name: string;
                loginUrl: string | null;
                faviconLink: string | null;
            };
            node: {
                uuid: string;
                name: string;
                countryCode: string;
            };
            nextBillingAt: string;
            createdAt: string;
            updatedAt: string;
        }>;
        availableBillingNodes: Array<{
            uuid: string;
            name: string;
            countryCode: string;
        }>;
        totalAvailableBillingNodes: number;
        stats: {
            upcomingNodesCount: number;
            currentMonthPayments: number;
            totalSpent: number;
        };
    };
};

export type UpdateInfraBillingNodeRequestDto = {
    uuids: Array<string>;
    nextBillingAt: string;
};

export type UpdateInfraBillingNodeResponseDto = {
    response: {
        totalBillingNodes: number;
        billingNodes: Array<{
            uuid: string;
            nodeUuid: string;
            providerUuid: string;
            provider: {
                uuid: string;
                name: string;
                loginUrl: string | null;
                faviconLink: string | null;
            };
            node: {
                uuid: string;
                name: string;
                countryCode: string;
            };
            nextBillingAt: string;
            createdAt: string;
            updatedAt: string;
        }>;
        availableBillingNodes: Array<{
            uuid: string;
            name: string;
            countryCode: string;
        }>;
        totalAvailableBillingNodes: number;
        stats: {
            upcomingNodesCount: number;
            currentMonthPayments: number;
            totalSpent: number;
        };
    };
};

export type CreateInfraBillingNodeRequestDto = {
    providerUuid: string;
    nodeUuid: string;
    /**
     * Next billing date. Format: 2025-01-17T15:38:45.065Z
     */
    nextBillingAt?: string;
};

export type CreateInfraBillingNodeResponseDto = {
    response: {
        totalBillingNodes: number;
        billingNodes: Array<{
            uuid: string;
            nodeUuid: string;
            providerUuid: string;
            provider: {
                uuid: string;
                name: string;
                loginUrl: string | null;
                faviconLink: string | null;
            };
            node: {
                uuid: string;
                name: string;
                countryCode: string;
            };
            nextBillingAt: string;
            createdAt: string;
            updatedAt: string;
        }>;
        availableBillingNodes: Array<{
            uuid: string;
            name: string;
            countryCode: string;
        }>;
        totalAvailableBillingNodes: number;
        stats: {
            upcomingNodesCount: number;
            currentMonthPayments: number;
            totalSpent: number;
        };
    };
};

export type DeleteInfraBillingNodeByUuidResponseDto = {
    response: {
        totalBillingNodes: number;
        billingNodes: Array<{
            uuid: string;
            nodeUuid: string;
            providerUuid: string;
            provider: {
                uuid: string;
                name: string;
                loginUrl: string | null;
                faviconLink: string | null;
            };
            node: {
                uuid: string;
                name: string;
                countryCode: string;
            };
            nextBillingAt: string;
            createdAt: string;
            updatedAt: string;
        }>;
        availableBillingNodes: Array<{
            uuid: string;
            name: string;
            countryCode: string;
        }>;
        totalAvailableBillingNodes: number;
        stats: {
            upcomingNodesCount: number;
            currentMonthPayments: number;
            totalSpent: number;
        };
    };
};

export type GetSubscriptionRequestHistoryResponseDto = {
    response: {
        records: Array<{
            id: number;
            userUuid: string;
            requestIp: string | null;
            userAgent: string | null;
            requestAt: string;
        }>;
        total: number;
    };
};

export type GetSubscriptionRequestHistoryStatsResponseDto = {
    response: {
        byParsedApp: Array<{
            app: string;
            count: number;
        }>;
        hourlyRequestStats: Array<{
            dateTime: string;
            requestCount: number;
        }>;
    };
};

export type GetStatsResponseDto = {
    response: {
        cpu: {
            cores: number;
            physicalCores: number;
        };
        memory: {
            total: number;
            free: number;
            used: number;
            active: number;
            available: number;
        };
        uptime: number;
        timestamp: number;
        users: {
            statusCounts: {
                [key: string]: number;
            };
            totalUsers: number;
        };
        onlineStats: {
            lastDay: number;
            lastWeek: number;
            neverOnline: number;
            onlineNow: number;
        };
        nodes: {
            totalOnline: number;
            totalBytesLifetime: string;
        };
    };
};

export type GetBandwidthStatsResponseDto = {
    response: {
        bandwidthLastTwoDays: {
            current: string;
            previous: string;
            difference: string;
        };
        bandwidthLastSevenDays: {
            current: string;
            previous: string;
            difference: string;
        };
        bandwidthLast30Days: {
            current: string;
            previous: string;
            difference: string;
        };
        bandwidthCalendarMonth: {
            current: string;
            previous: string;
            difference: string;
        };
        bandwidthCurrentYear: {
            current: string;
            previous: string;
            difference: string;
        };
    };
};

export type GetNodesStatisticsResponseDto = {
    response: {
        lastSevenDays: Array<{
            nodeName: string;
            date: string;
            totalBytes: string;
        }>;
    };
};

export type GetRemnawaveHealthResponseDto = {
    response: {
        pm2Stats: Array<{
            name: string;
            memory: string;
            cpu: string;
        }>;
    };
};

export type GetNodesMetricsResponseDto = {
    response: {
        nodes: Array<{
            nodeUuid: string;
            nodeName: string;
            countryEmoji: string;
            providerName: string;
            usersOnline: number;
            inboundsStats: Array<{
                tag: string;
                upload: string;
                download: string;
            }>;
            outboundsStats: Array<{
                tag: string;
                upload: string;
                download: string;
            }>;
        }>;
    };
};

export type GenerateX25519ResponseDto = {
    response: {
        keypairs: Array<{
            publicKey: string;
            privateKey: string;
        }>;
    };
};

export type EncryptHappCryptoLinkRequestDto = {
    linkToEncrypt: string;
};

export type EncryptHappCryptoLinkResponseDto = {
    response: {
        encryptedLink: string;
    };
};

export type DebugSrrMatcherRequestDto = {
    responseRules: {
        /**
         * {"title":"Response Rules Config Version","markdownDescription":"Version of the **response rules** config. Currently supported version is **1**."}
         */
        version: '1';
        /**
         * {"title":"Response Rules","markdownDescription":"Array of **response rules**. Rules are evaluated in order and the first rule that matches is applied. If no rule matches, request will be blocked by default.\n\n**Example:**\n```json\n[\n  {\n    \"name\": \"Blank rule\",\n    \"description\": \"Blank rule\",\n    \"operator\": \"AND\",\n    \"enabled\": true,\n    \"conditions\": [],\n    \"responseType\": \"BLOCK\",\n    \"responseModifications\": {\n      \"headers\": []\n    }\n  }\n]\n```","defaultSnippets":[]}
         */
        rules: Array<{
            /**
             * {"markdownDescription":"Name of the response rule."}
             */
            name: string;
            /**
             * {"markdownDescription":"Description of the response rule. Optional."}
             */
            description?: string;
            /**
             * {"markdownDescription":"Control whether the response rule is enabled or disabled. \n\n - `true` the rule will be applied. \n\n - `false` the rule will be always ignored."}
             */
            enabled: boolean;
            /**
             * {"markdownDescription":"Operator to use for combining conditions in the rule."}
             */
            operator: 'AND' | 'OR';
            /**
             * {"markdownDescription":"Array of conditions to check against the request headers. Conditions are applied with **operator**. If conditions are empty, the rule will be matched."}
             */
            conditions: Array<{
                /**
                 * {"markdownDescription":"**Name** of the HTTP header to check. Must comply with RFC 7230."}
                 */
                headerName: string;
                /**
                 * {"errorMessage":"Invalid operator. Please select a valid operator.","markdownDescription":"Operator to use for comparing the `headerName` with `value`.","markdownEnumDescriptions":["Performs an exact, comparison between the header value and specified string. `string === value`","Ensures the header value does not exactly match the specified string. `string !== value`","Checks if the header value contains the specified string as a substring. `string.includes()`","Verifies the header value does not contain the specified string as a substring. `!string.includes()`","Validates that the header value begins with the specified string. `string.startsWith()`","Validates that the header value does not begin with the specified string. `!string.startsWith()`","Confirms the header value ends with the specified string. `string.endsWith()`","Confirms the header value does not end with the specified string. `!string.endsWith()`","Evaluates if the header value matches the specified regular expression pattern. `regex.test()`","Evaluates if the header value does not match the specified regular expression pattern. `!regex.test()`"]}
                 */
                operator: 'EQUALS' | 'NOT_EQUALS' | 'CONTAINS' | 'NOT_CONTAINS' | 'STARTS_WITH' | 'NOT_STARTS_WITH' | 'ENDS_WITH' | 'NOT_ENDS_WITH' | 'REGEX' | 'NOT_REGEX';
                /**
                 * {"markdownDescription":"**Value** to check against the **headerName**."}
                 */
                value: string;
                /**
                 * {"markdownDescription":"Whether the value is **case sensitive**. \n\n - `true`: the value will be compared as is. \n\n - `false`: the value will be lowercased **before** comparison."}
                 */
                caseSensitive: boolean;
            }>;
            /**
             * {"errorMessage":"Invalid response type. Please select a valid response type.","markdownDescription":"Type of the response. Determines the type of **response** to be returned when the rule is matched.","markdownEnumDescriptions":["Return **subscription** in XRAY-JSON format. (Using `Xray Json` template)","Return **subscription** in BASE64 encoded string. Compatible with most client application with Xray core.","Return **subscription** in Mihomo format. (Using `Mihomo` template)","Return **subscription** in Stash format. (Using `Stash` template)","Return **subscription** in Clash format. (Using `Clash` template) Useful for client application that use Legacy Clash core.","Return **subscription** in Singbox format. (Using `Singbox` template) Format which is used by Singbox client application.","Return **subscription** as browser format. The same as on `/info` route.","**Drop** request and return `403` status code.","**Drop** request and return `404` status code.","**Drop** request and return `451` status code.","**Drop** the socket connection."]}
             */
            responseType: 'XRAY_JSON' | 'XRAY_BASE64' | 'MIHOMO' | 'STASH' | 'CLASH' | 'SINGBOX' | 'BROWSER' | 'BLOCK' | 'STATUS_CODE_404' | 'STATUS_CODE_451' | 'SOCKET_DROP';
            /**
             * {"examples":[{"headers":[{"key":"X-Custom-Header","value":"CustomValue"}]}],"markdownDescription":"Response modifications to be applied when the rule is matched. Optional."}
             */
            responseModifications?: {
                /**
                 * {"defaultSnippets":[{"label":"Examples: Add custom header","markdownDescription":"Add a custom header to the response","body":[{"key":"X-Custom-Header","value":"CustomValue"}]}],"markdownDescription":"Array of headers to be added when the rule is matched."}
                 */
                headers?: Array<{
                    /**
                     * {"markdownDescription":"Key of the response header. Must comply with RFC 7230."}
                     */
                    key: string;
                    /**
                     * {"markdownDescription":"Value of the response header. "}
                     */
                    value: string;
                }>;
                /**
                 * {"markdownDescription":"Override the subscription template with the given name. If not provided, the default subscription template will be used. If the template name is not found, the default subscription template for this type will be used. **This modification have higher priority than settings from External Squads.**"}
                 */
                subscriptionTemplate?: string;
            };
        }>;
    };
};

export type DebugSrrMatcherResponseDto = {
    response: {
        matched: boolean;
        responseType: 'XRAY_JSON' | 'XRAY_BASE64' | 'MIHOMO' | 'STASH' | 'CLASH' | 'SINGBOX' | 'BROWSER' | 'BLOCK' | 'STATUS_CODE_404' | 'STATUS_CODE_451' | 'SOCKET_DROP';
        /**
         * {"defaultSnippets":[{"label":"Examples: Blank rule","markdownDescription":"Simple blank rule with no conditions or modifications.\n```json\n{\n  \"name\": \"Blank rule\",\n  \"description\": \"Blank rule\",\n  \"operator\": \"AND\",\n  \"enabled\": true,\n  \"conditions\": [],\n  \"responseType\": \"BLOCK\",\n  \"responseModifications\": {\n    \"headers\": []\n  }\n}\n```","body":{"name":"Blank rule","description":"Blank rule","operator":"AND","enabled":true,"conditions":[],"responseType":"BLOCK","responseModifications":{"headers":[]}}},{"label":"Examples: Block Legacy Clients","markdownDescription":"Block requests from legacy clients\n```json\n{\n  \"name\": \"Block Legacy Clients\",\n  \"description\": \"Block requests from legacy clients\",\n  \"enabled\": true,\n  \"operator\": \"OR\",\n  \"conditions\": [\n    {\n      \"headerName\": \"user-agent\",\n      \"operator\": \"CONTAINS\",\n      \"value\": \"Hiddify\",\n      \"caseSensitive\": true\n    },\n    {\n      \"headerName\": \"user-agent\",\n      \"operator\": \"CONTAINS\",\n      \"value\": \"FoxRay\",\n      \"caseSensitive\": true\n    }\n  ],\n  \"responseType\": \"BLOCK\"\n}\n```","body":{"name":"Block Legacy Clients","description":"Block requests from legacy clients","enabled":true,"operator":"OR","conditions":[{"headerName":"user-agent","operator":"CONTAINS","value":"Hiddify","caseSensitive":true},{"headerName":"user-agent","operator":"CONTAINS","value":"FoxRay","caseSensitive":true}],"responseType":"BLOCK"}}],"title":"Response Rule","markdownDescription":"Response rule configuration.\n\n**Fields:**\n- **name**: Name of the response rule.\n- **description**: Description of the response rule. Optional.\n- **enabled**: Control whether the response rule is enabled or disabled. \n\n - `true` the rule will be applied. \n\n - `false` the rule will be always ignored.\n- **operator**: Operator to use for combining conditions in the rule.\n- **conditions**: Array of conditions to check against the request headers. Conditions are applied with **operator**. If conditions are empty, the rule will be matched.\n- **responseType**: Type of the response. Determines the type of **response** to be returned when the rule is matched.\n- **responseModifications**: Response modifications to be applied when the rule is matched. Optional.\n\n**Example:**\n```json\n{\n  \"name\": \"Block Legacy Clients\",\n  \"description\": \"Block requests from legacy clients\",\n  \"enabled\": true,\n  \"operator\": \"OR\",\n  \"conditions\": [\n    {\n      \"headerName\": \"user-agent\",\n      \"operator\": \"CONTAINS\",\n      \"value\": \"Hiddify\",\n      \"caseSensitive\": true\n    },\n    {\n      \"headerName\": \"user-agent\",\n      \"operator\": \"CONTAINS\",\n      \"value\": \"FoxRay\",\n      \"caseSensitive\": true\n    }\n  ],\n  \"responseType\": \"BLOCK\"\n}\n```"}
         */
        matchedRule: {
            /**
             * {"markdownDescription":"Name of the response rule."}
             */
            name: string;
            /**
             * {"markdownDescription":"Description of the response rule. Optional."}
             */
            description?: string;
            /**
             * {"markdownDescription":"Control whether the response rule is enabled or disabled. \n\n - `true` the rule will be applied. \n\n - `false` the rule will be always ignored."}
             */
            enabled: boolean;
            /**
             * {"markdownDescription":"Operator to use for combining conditions in the rule."}
             */
            operator: 'AND' | 'OR';
            /**
             * {"markdownDescription":"Array of conditions to check against the request headers. Conditions are applied with **operator**. If conditions are empty, the rule will be matched."}
             */
            conditions: Array<{
                /**
                 * {"markdownDescription":"**Name** of the HTTP header to check. Must comply with RFC 7230."}
                 */
                headerName: string;
                /**
                 * {"errorMessage":"Invalid operator. Please select a valid operator.","markdownDescription":"Operator to use for comparing the `headerName` with `value`.","markdownEnumDescriptions":["Performs an exact, comparison between the header value and specified string. `string === value`","Ensures the header value does not exactly match the specified string. `string !== value`","Checks if the header value contains the specified string as a substring. `string.includes()`","Verifies the header value does not contain the specified string as a substring. `!string.includes()`","Validates that the header value begins with the specified string. `string.startsWith()`","Validates that the header value does not begin with the specified string. `!string.startsWith()`","Confirms the header value ends with the specified string. `string.endsWith()`","Confirms the header value does not end with the specified string. `!string.endsWith()`","Evaluates if the header value matches the specified regular expression pattern. `regex.test()`","Evaluates if the header value does not match the specified regular expression pattern. `!regex.test()`"]}
                 */
                operator: 'EQUALS' | 'NOT_EQUALS' | 'CONTAINS' | 'NOT_CONTAINS' | 'STARTS_WITH' | 'NOT_STARTS_WITH' | 'ENDS_WITH' | 'NOT_ENDS_WITH' | 'REGEX' | 'NOT_REGEX';
                /**
                 * {"markdownDescription":"**Value** to check against the **headerName**."}
                 */
                value: string;
                /**
                 * {"markdownDescription":"Whether the value is **case sensitive**. \n\n - `true`: the value will be compared as is. \n\n - `false`: the value will be lowercased **before** comparison."}
                 */
                caseSensitive: boolean;
            }>;
            /**
             * {"errorMessage":"Invalid response type. Please select a valid response type.","markdownDescription":"Type of the response. Determines the type of **response** to be returned when the rule is matched.","markdownEnumDescriptions":["Return **subscription** in XRAY-JSON format. (Using `Xray Json` template)","Return **subscription** in BASE64 encoded string. Compatible with most client application with Xray core.","Return **subscription** in Mihomo format. (Using `Mihomo` template)","Return **subscription** in Stash format. (Using `Stash` template)","Return **subscription** in Clash format. (Using `Clash` template) Useful for client application that use Legacy Clash core.","Return **subscription** in Singbox format. (Using `Singbox` template) Format which is used by Singbox client application.","Return **subscription** as browser format. The same as on `/info` route.","**Drop** request and return `403` status code.","**Drop** request and return `404` status code.","**Drop** request and return `451` status code.","**Drop** the socket connection."]}
             */
            responseType: 'XRAY_JSON' | 'XRAY_BASE64' | 'MIHOMO' | 'STASH' | 'CLASH' | 'SINGBOX' | 'BROWSER' | 'BLOCK' | 'STATUS_CODE_404' | 'STATUS_CODE_451' | 'SOCKET_DROP';
            /**
             * {"examples":[{"headers":[{"key":"X-Custom-Header","value":"CustomValue"}]}],"markdownDescription":"Response modifications to be applied when the rule is matched. Optional."}
             */
            responseModifications?: {
                /**
                 * {"defaultSnippets":[{"label":"Examples: Add custom header","markdownDescription":"Add a custom header to the response","body":[{"key":"X-Custom-Header","value":"CustomValue"}]}],"markdownDescription":"Array of headers to be added when the rule is matched."}
                 */
                headers?: Array<{
                    /**
                     * {"markdownDescription":"Key of the response header. Must comply with RFC 7230."}
                     */
                    key: string;
                    /**
                     * {"markdownDescription":"Value of the response header. "}
                     */
                    value: string;
                }>;
                /**
                 * {"markdownDescription":"Override the subscription template with the given name. If not provided, the default subscription template will be used. If the template name is not found, the default subscription template for this type will be used. **This modification have higher priority than settings from External Squads.**"}
                 */
                subscriptionTemplate?: string;
            };
        } | null;
        inputHeaders: {
            [key: string]: string;
        };
        outputHeaders: {
            [key: string]: string;
        };
    };
};

export type GetSubscriptionSettingsResponseDto = {
    response: {
        uuid: string;
        profileTitle: string;
        supportLink: string;
        profileUpdateInterval: number;
        isProfileWebpageUrlEnabled: boolean;
        serveJsonAtBaseSubscription: boolean;
        isShowCustomRemarks: boolean;
        customRemarks: {
            expiredUsers: Array<string>;
            limitedUsers: Array<string>;
            disabledUsers: Array<string>;
            emptyHosts: Array<string>;
            emptyInternalSquads: Array<string>;
        };
        happAnnounce: string | null;
        happRouting: string | null;
        customResponseHeaders: {
            [key: string]: string;
        } | null;
        randomizeHosts: boolean;
        responseRules: {
            /**
             * {"title":"Response Rules Config Version","markdownDescription":"Version of the **response rules** config. Currently supported version is **1**."}
             */
            version: '1';
            /**
             * {"title":"Response Rules","markdownDescription":"Array of **response rules**. Rules are evaluated in order and the first rule that matches is applied. If no rule matches, request will be blocked by default.\n\n**Example:**\n```json\n[\n  {\n    \"name\": \"Blank rule\",\n    \"description\": \"Blank rule\",\n    \"operator\": \"AND\",\n    \"enabled\": true,\n    \"conditions\": [],\n    \"responseType\": \"BLOCK\",\n    \"responseModifications\": {\n      \"headers\": []\n    }\n  }\n]\n```","defaultSnippets":[]}
             */
            rules: Array<{
                /**
                 * {"markdownDescription":"Name of the response rule."}
                 */
                name: string;
                /**
                 * {"markdownDescription":"Description of the response rule. Optional."}
                 */
                description?: string;
                /**
                 * {"markdownDescription":"Control whether the response rule is enabled or disabled. \n\n - `true` the rule will be applied. \n\n - `false` the rule will be always ignored."}
                 */
                enabled: boolean;
                /**
                 * {"markdownDescription":"Operator to use for combining conditions in the rule."}
                 */
                operator: 'AND' | 'OR';
                /**
                 * {"markdownDescription":"Array of conditions to check against the request headers. Conditions are applied with **operator**. If conditions are empty, the rule will be matched."}
                 */
                conditions: Array<{
                    /**
                     * {"markdownDescription":"**Name** of the HTTP header to check. Must comply with RFC 7230."}
                     */
                    headerName: string;
                    /**
                     * {"errorMessage":"Invalid operator. Please select a valid operator.","markdownDescription":"Operator to use for comparing the `headerName` with `value`.","markdownEnumDescriptions":["Performs an exact, comparison between the header value and specified string. `string === value`","Ensures the header value does not exactly match the specified string. `string !== value`","Checks if the header value contains the specified string as a substring. `string.includes()`","Verifies the header value does not contain the specified string as a substring. `!string.includes()`","Validates that the header value begins with the specified string. `string.startsWith()`","Validates that the header value does not begin with the specified string. `!string.startsWith()`","Confirms the header value ends with the specified string. `string.endsWith()`","Confirms the header value does not end with the specified string. `!string.endsWith()`","Evaluates if the header value matches the specified regular expression pattern. `regex.test()`","Evaluates if the header value does not match the specified regular expression pattern. `!regex.test()`"]}
                     */
                    operator: 'EQUALS' | 'NOT_EQUALS' | 'CONTAINS' | 'NOT_CONTAINS' | 'STARTS_WITH' | 'NOT_STARTS_WITH' | 'ENDS_WITH' | 'NOT_ENDS_WITH' | 'REGEX' | 'NOT_REGEX';
                    /**
                     * {"markdownDescription":"**Value** to check against the **headerName**."}
                     */
                    value: string;
                    /**
                     * {"markdownDescription":"Whether the value is **case sensitive**. \n\n - `true`: the value will be compared as is. \n\n - `false`: the value will be lowercased **before** comparison."}
                     */
                    caseSensitive: boolean;
                }>;
                /**
                 * {"errorMessage":"Invalid response type. Please select a valid response type.","markdownDescription":"Type of the response. Determines the type of **response** to be returned when the rule is matched.","markdownEnumDescriptions":["Return **subscription** in XRAY-JSON format. (Using `Xray Json` template)","Return **subscription** in BASE64 encoded string. Compatible with most client application with Xray core.","Return **subscription** in Mihomo format. (Using `Mihomo` template)","Return **subscription** in Stash format. (Using `Stash` template)","Return **subscription** in Clash format. (Using `Clash` template) Useful for client application that use Legacy Clash core.","Return **subscription** in Singbox format. (Using `Singbox` template) Format which is used by Singbox client application.","Return **subscription** as browser format. The same as on `/info` route.","**Drop** request and return `403` status code.","**Drop** request and return `404` status code.","**Drop** request and return `451` status code.","**Drop** the socket connection."]}
                 */
                responseType: 'XRAY_JSON' | 'XRAY_BASE64' | 'MIHOMO' | 'STASH' | 'CLASH' | 'SINGBOX' | 'BROWSER' | 'BLOCK' | 'STATUS_CODE_404' | 'STATUS_CODE_451' | 'SOCKET_DROP';
                /**
                 * {"examples":[{"headers":[{"key":"X-Custom-Header","value":"CustomValue"}]}],"markdownDescription":"Response modifications to be applied when the rule is matched. Optional."}
                 */
                responseModifications?: {
                    /**
                     * {"defaultSnippets":[{"label":"Examples: Add custom header","markdownDescription":"Add a custom header to the response","body":[{"key":"X-Custom-Header","value":"CustomValue"}]}],"markdownDescription":"Array of headers to be added when the rule is matched."}
                     */
                    headers?: Array<{
                        /**
                         * {"markdownDescription":"Key of the response header. Must comply with RFC 7230."}
                         */
                        key: string;
                        /**
                         * {"markdownDescription":"Value of the response header. "}
                         */
                        value: string;
                    }>;
                    /**
                     * {"markdownDescription":"Override the subscription template with the given name. If not provided, the default subscription template will be used. If the template name is not found, the default subscription template for this type will be used. **This modification have higher priority than settings from External Squads.**"}
                     */
                    subscriptionTemplate?: string;
                };
            }>;
        } | null;
        hwidSettings: {
            enabled: boolean;
            fallbackDeviceLimit: number;
            maxDevicesAnnounce: string | null;
        } | null;
        createdAt: string;
        updatedAt: string;
    };
};

export type UpdateSubscriptionSettingsRequestDto = {
    uuid: string;
    profileTitle?: string;
    supportLink?: string;
    profileUpdateInterval?: number;
    isProfileWebpageUrlEnabled?: boolean;
    serveJsonAtBaseSubscription?: boolean;
    happAnnounce?: string | null;
    happRouting?: string | null;
    isShowCustomRemarks?: boolean;
    customRemarks?: {
        expiredUsers: Array<string>;
        limitedUsers: Array<string>;
        disabledUsers: Array<string>;
        emptyHosts: Array<string>;
        emptyInternalSquads: Array<string>;
    };
    customResponseHeaders?: {
        [key: string]: string;
    };
    randomizeHosts?: boolean;
    responseRules?: {
        /**
         * {"title":"Response Rules Config Version","markdownDescription":"Version of the **response rules** config. Currently supported version is **1**."}
         */
        version: '1';
        /**
         * {"title":"Response Rules","markdownDescription":"Array of **response rules**. Rules are evaluated in order and the first rule that matches is applied. If no rule matches, request will be blocked by default.\n\n**Example:**\n```json\n[\n  {\n    \"name\": \"Blank rule\",\n    \"description\": \"Blank rule\",\n    \"operator\": \"AND\",\n    \"enabled\": true,\n    \"conditions\": [],\n    \"responseType\": \"BLOCK\",\n    \"responseModifications\": {\n      \"headers\": []\n    }\n  }\n]\n```","defaultSnippets":[]}
         */
        rules: Array<{
            /**
             * {"markdownDescription":"Name of the response rule."}
             */
            name: string;
            /**
             * {"markdownDescription":"Description of the response rule. Optional."}
             */
            description?: string;
            /**
             * {"markdownDescription":"Control whether the response rule is enabled or disabled. \n\n - `true` the rule will be applied. \n\n - `false` the rule will be always ignored."}
             */
            enabled: boolean;
            /**
             * {"markdownDescription":"Operator to use for combining conditions in the rule."}
             */
            operator: 'AND' | 'OR';
            /**
             * {"markdownDescription":"Array of conditions to check against the request headers. Conditions are applied with **operator**. If conditions are empty, the rule will be matched."}
             */
            conditions: Array<{
                /**
                 * {"markdownDescription":"**Name** of the HTTP header to check. Must comply with RFC 7230."}
                 */
                headerName: string;
                /**
                 * {"errorMessage":"Invalid operator. Please select a valid operator.","markdownDescription":"Operator to use for comparing the `headerName` with `value`.","markdownEnumDescriptions":["Performs an exact, comparison between the header value and specified string. `string === value`","Ensures the header value does not exactly match the specified string. `string !== value`","Checks if the header value contains the specified string as a substring. `string.includes()`","Verifies the header value does not contain the specified string as a substring. `!string.includes()`","Validates that the header value begins with the specified string. `string.startsWith()`","Validates that the header value does not begin with the specified string. `!string.startsWith()`","Confirms the header value ends with the specified string. `string.endsWith()`","Confirms the header value does not end with the specified string. `!string.endsWith()`","Evaluates if the header value matches the specified regular expression pattern. `regex.test()`","Evaluates if the header value does not match the specified regular expression pattern. `!regex.test()`"]}
                 */
                operator: 'EQUALS' | 'NOT_EQUALS' | 'CONTAINS' | 'NOT_CONTAINS' | 'STARTS_WITH' | 'NOT_STARTS_WITH' | 'ENDS_WITH' | 'NOT_ENDS_WITH' | 'REGEX' | 'NOT_REGEX';
                /**
                 * {"markdownDescription":"**Value** to check against the **headerName**."}
                 */
                value: string;
                /**
                 * {"markdownDescription":"Whether the value is **case sensitive**. \n\n - `true`: the value will be compared as is. \n\n - `false`: the value will be lowercased **before** comparison."}
                 */
                caseSensitive: boolean;
            }>;
            /**
             * {"errorMessage":"Invalid response type. Please select a valid response type.","markdownDescription":"Type of the response. Determines the type of **response** to be returned when the rule is matched.","markdownEnumDescriptions":["Return **subscription** in XRAY-JSON format. (Using `Xray Json` template)","Return **subscription** in BASE64 encoded string. Compatible with most client application with Xray core.","Return **subscription** in Mihomo format. (Using `Mihomo` template)","Return **subscription** in Stash format. (Using `Stash` template)","Return **subscription** in Clash format. (Using `Clash` template) Useful for client application that use Legacy Clash core.","Return **subscription** in Singbox format. (Using `Singbox` template) Format which is used by Singbox client application.","Return **subscription** as browser format. The same as on `/info` route.","**Drop** request and return `403` status code.","**Drop** request and return `404` status code.","**Drop** request and return `451` status code.","**Drop** the socket connection."]}
             */
            responseType: 'XRAY_JSON' | 'XRAY_BASE64' | 'MIHOMO' | 'STASH' | 'CLASH' | 'SINGBOX' | 'BROWSER' | 'BLOCK' | 'STATUS_CODE_404' | 'STATUS_CODE_451' | 'SOCKET_DROP';
            /**
             * {"examples":[{"headers":[{"key":"X-Custom-Header","value":"CustomValue"}]}],"markdownDescription":"Response modifications to be applied when the rule is matched. Optional."}
             */
            responseModifications?: {
                /**
                 * {"defaultSnippets":[{"label":"Examples: Add custom header","markdownDescription":"Add a custom header to the response","body":[{"key":"X-Custom-Header","value":"CustomValue"}]}],"markdownDescription":"Array of headers to be added when the rule is matched."}
                 */
                headers?: Array<{
                    /**
                     * {"markdownDescription":"Key of the response header. Must comply with RFC 7230."}
                     */
                    key: string;
                    /**
                     * {"markdownDescription":"Value of the response header. "}
                     */
                    value: string;
                }>;
                /**
                 * {"markdownDescription":"Override the subscription template with the given name. If not provided, the default subscription template will be used. If the template name is not found, the default subscription template for this type will be used. **This modification have higher priority than settings from External Squads.**"}
                 */
                subscriptionTemplate?: string;
            };
        }>;
    };
    hwidSettings?: {
        enabled: boolean;
        fallbackDeviceLimit: number;
        maxDevicesAnnounce: string | null;
    };
};

export type UpdateSubscriptionSettingsResponseDto = {
    response: {
        uuid: string;
        profileTitle: string;
        supportLink: string;
        profileUpdateInterval: number;
        isProfileWebpageUrlEnabled: boolean;
        serveJsonAtBaseSubscription: boolean;
        isShowCustomRemarks: boolean;
        customRemarks: {
            expiredUsers: Array<string>;
            limitedUsers: Array<string>;
            disabledUsers: Array<string>;
            emptyHosts: Array<string>;
            emptyInternalSquads: Array<string>;
        };
        happAnnounce: string | null;
        happRouting: string | null;
        customResponseHeaders: {
            [key: string]: string;
        } | null;
        randomizeHosts: boolean;
        responseRules: {
            /**
             * {"title":"Response Rules Config Version","markdownDescription":"Version of the **response rules** config. Currently supported version is **1**."}
             */
            version: '1';
            /**
             * {"title":"Response Rules","markdownDescription":"Array of **response rules**. Rules are evaluated in order and the first rule that matches is applied. If no rule matches, request will be blocked by default.\n\n**Example:**\n```json\n[\n  {\n    \"name\": \"Blank rule\",\n    \"description\": \"Blank rule\",\n    \"operator\": \"AND\",\n    \"enabled\": true,\n    \"conditions\": [],\n    \"responseType\": \"BLOCK\",\n    \"responseModifications\": {\n      \"headers\": []\n    }\n  }\n]\n```","defaultSnippets":[]}
             */
            rules: Array<{
                /**
                 * {"markdownDescription":"Name of the response rule."}
                 */
                name: string;
                /**
                 * {"markdownDescription":"Description of the response rule. Optional."}
                 */
                description?: string;
                /**
                 * {"markdownDescription":"Control whether the response rule is enabled or disabled. \n\n - `true` the rule will be applied. \n\n - `false` the rule will be always ignored."}
                 */
                enabled: boolean;
                /**
                 * {"markdownDescription":"Operator to use for combining conditions in the rule."}
                 */
                operator: 'AND' | 'OR';
                /**
                 * {"markdownDescription":"Array of conditions to check against the request headers. Conditions are applied with **operator**. If conditions are empty, the rule will be matched."}
                 */
                conditions: Array<{
                    /**
                     * {"markdownDescription":"**Name** of the HTTP header to check. Must comply with RFC 7230."}
                     */
                    headerName: string;
                    /**
                     * {"errorMessage":"Invalid operator. Please select a valid operator.","markdownDescription":"Operator to use for comparing the `headerName` with `value`.","markdownEnumDescriptions":["Performs an exact, comparison between the header value and specified string. `string === value`","Ensures the header value does not exactly match the specified string. `string !== value`","Checks if the header value contains the specified string as a substring. `string.includes()`","Verifies the header value does not contain the specified string as a substring. `!string.includes()`","Validates that the header value begins with the specified string. `string.startsWith()`","Validates that the header value does not begin with the specified string. `!string.startsWith()`","Confirms the header value ends with the specified string. `string.endsWith()`","Confirms the header value does not end with the specified string. `!string.endsWith()`","Evaluates if the header value matches the specified regular expression pattern. `regex.test()`","Evaluates if the header value does not match the specified regular expression pattern. `!regex.test()`"]}
                     */
                    operator: 'EQUALS' | 'NOT_EQUALS' | 'CONTAINS' | 'NOT_CONTAINS' | 'STARTS_WITH' | 'NOT_STARTS_WITH' | 'ENDS_WITH' | 'NOT_ENDS_WITH' | 'REGEX' | 'NOT_REGEX';
                    /**
                     * {"markdownDescription":"**Value** to check against the **headerName**."}
                     */
                    value: string;
                    /**
                     * {"markdownDescription":"Whether the value is **case sensitive**. \n\n - `true`: the value will be compared as is. \n\n - `false`: the value will be lowercased **before** comparison."}
                     */
                    caseSensitive: boolean;
                }>;
                /**
                 * {"errorMessage":"Invalid response type. Please select a valid response type.","markdownDescription":"Type of the response. Determines the type of **response** to be returned when the rule is matched.","markdownEnumDescriptions":["Return **subscription** in XRAY-JSON format. (Using `Xray Json` template)","Return **subscription** in BASE64 encoded string. Compatible with most client application with Xray core.","Return **subscription** in Mihomo format. (Using `Mihomo` template)","Return **subscription** in Stash format. (Using `Stash` template)","Return **subscription** in Clash format. (Using `Clash` template) Useful for client application that use Legacy Clash core.","Return **subscription** in Singbox format. (Using `Singbox` template) Format which is used by Singbox client application.","Return **subscription** as browser format. The same as on `/info` route.","**Drop** request and return `403` status code.","**Drop** request and return `404` status code.","**Drop** request and return `451` status code.","**Drop** the socket connection."]}
                 */
                responseType: 'XRAY_JSON' | 'XRAY_BASE64' | 'MIHOMO' | 'STASH' | 'CLASH' | 'SINGBOX' | 'BROWSER' | 'BLOCK' | 'STATUS_CODE_404' | 'STATUS_CODE_451' | 'SOCKET_DROP';
                /**
                 * {"examples":[{"headers":[{"key":"X-Custom-Header","value":"CustomValue"}]}],"markdownDescription":"Response modifications to be applied when the rule is matched. Optional."}
                 */
                responseModifications?: {
                    /**
                     * {"defaultSnippets":[{"label":"Examples: Add custom header","markdownDescription":"Add a custom header to the response","body":[{"key":"X-Custom-Header","value":"CustomValue"}]}],"markdownDescription":"Array of headers to be added when the rule is matched."}
                     */
                    headers?: Array<{
                        /**
                         * {"markdownDescription":"Key of the response header. Must comply with RFC 7230."}
                         */
                        key: string;
                        /**
                         * {"markdownDescription":"Value of the response header. "}
                         */
                        value: string;
                    }>;
                    /**
                     * {"markdownDescription":"Override the subscription template with the given name. If not provided, the default subscription template will be used. If the template name is not found, the default subscription template for this type will be used. **This modification have higher priority than settings from External Squads.**"}
                     */
                    subscriptionTemplate?: string;
                };
            }>;
        } | null;
        hwidSettings: {
            enabled: boolean;
            fallbackDeviceLimit: number;
            maxDevicesAnnounce: string | null;
        } | null;
        createdAt: string;
        updatedAt: string;
    };
};

export type RemnawaveSettingsControllerGetSettingsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/remnawave-settings';
};

export type RemnawaveSettingsControllerGetSettingsErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type RemnawaveSettingsControllerGetSettingsError = RemnawaveSettingsControllerGetSettingsErrors[keyof RemnawaveSettingsControllerGetSettingsErrors];

export type RemnawaveSettingsControllerGetSettingsResponses = {
    /**
     * Remnawave settings retrieved successfully
     */
    200: GetRemnawaveSettingsResponseDto;
};

export type RemnawaveSettingsControllerGetSettingsResponse = RemnawaveSettingsControllerGetSettingsResponses[keyof RemnawaveSettingsControllerGetSettingsResponses];

export type RemnawaveSettingsControllerUpdateSettingsData = {
    body: UpdateRemnawaveSettingsRequestDto;
    path?: never;
    query?: never;
    url: '/api/remnawave-settings';
};

export type RemnawaveSettingsControllerUpdateSettingsErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type RemnawaveSettingsControllerUpdateSettingsError = RemnawaveSettingsControllerUpdateSettingsErrors[keyof RemnawaveSettingsControllerUpdateSettingsErrors];

export type RemnawaveSettingsControllerUpdateSettingsResponses = {
    /**
     * Subscription settings updated successfully
     */
    200: UpdateRemnawaveSettingsResponseDto;
};

export type RemnawaveSettingsControllerUpdateSettingsResponse = RemnawaveSettingsControllerUpdateSettingsResponses[keyof RemnawaveSettingsControllerUpdateSettingsResponses];

export type PasskeyControllerPasskeyRegistrationOptionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/passkeys/registration/options';
};

export type PasskeyControllerPasskeyRegistrationOptionsErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type PasskeyControllerPasskeyRegistrationOptionsError = PasskeyControllerPasskeyRegistrationOptionsErrors[keyof PasskeyControllerPasskeyRegistrationOptionsErrors];

export type PasskeyControllerPasskeyRegistrationOptionsResponses = {
    /**
     * Get passkey registration options
     */
    default: GetPasskeyRegistrationOptionsResponseDto;
};

export type PasskeyControllerPasskeyRegistrationOptionsResponse = PasskeyControllerPasskeyRegistrationOptionsResponses[keyof PasskeyControllerPasskeyRegistrationOptionsResponses];

export type PasskeyControllerPasskeyRegistrationVerifyData = {
    body: VerifyPasskeyRegistrationRequestDto;
    path?: never;
    query?: never;
    url: '/api/passkeys/registration/verify';
};

export type PasskeyControllerPasskeyRegistrationVerifyErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type PasskeyControllerPasskeyRegistrationVerifyError = PasskeyControllerPasskeyRegistrationVerifyErrors[keyof PasskeyControllerPasskeyRegistrationVerifyErrors];

export type PasskeyControllerPasskeyRegistrationVerifyResponses = {
    /**
     * Verify passkey registration result
     */
    default: VerifyPasskeyRegistrationResponseDto;
};

export type PasskeyControllerPasskeyRegistrationVerifyResponse = PasskeyControllerPasskeyRegistrationVerifyResponses[keyof PasskeyControllerPasskeyRegistrationVerifyResponses];

export type PasskeyControllerDeletePasskeyData = {
    body: DeletePasskeyRequestDto;
    path?: never;
    query?: never;
    url: '/api/passkeys';
};

export type PasskeyControllerDeletePasskeyErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type PasskeyControllerDeletePasskeyError = PasskeyControllerDeletePasskeyErrors[keyof PasskeyControllerDeletePasskeyErrors];

export type PasskeyControllerDeletePasskeyResponses = {
    /**
     * Delete passkey result
     */
    default: DeletePasskeyResponseDto;
};

export type PasskeyControllerDeletePasskeyResponse = PasskeyControllerDeletePasskeyResponses[keyof PasskeyControllerDeletePasskeyResponses];

export type PasskeyControllerGetActivePasskeysData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/passkeys';
};

export type PasskeyControllerGetActivePasskeysErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type PasskeyControllerGetActivePasskeysError = PasskeyControllerGetActivePasskeysErrors[keyof PasskeyControllerGetActivePasskeysErrors];

export type PasskeyControllerGetActivePasskeysResponses = {
    /**
     * Get all passkeys
     */
    default: GetAllPasskeysResponseDto;
};

export type PasskeyControllerGetActivePasskeysResponse = PasskeyControllerGetActivePasskeysResponses[keyof PasskeyControllerGetActivePasskeysResponses];

export type PasskeyControllerUpdatePasskeyData = {
    body: UpdatePasskeyRequestDto;
    path?: never;
    query?: never;
    url: '/api/passkeys';
};

export type PasskeyControllerUpdatePasskeyErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type PasskeyControllerUpdatePasskeyError = PasskeyControllerUpdatePasskeyErrors[keyof PasskeyControllerUpdatePasskeyErrors];

export type PasskeyControllerUpdatePasskeyResponses = {
    /**
     * Update passkey
     */
    default: UpdatePasskeyResponseDto;
};

export type PasskeyControllerUpdatePasskeyResponse = PasskeyControllerUpdatePasskeyResponses[keyof PasskeyControllerUpdatePasskeyResponses];

export type AuthControllerLoginData = {
    body: LoginRequestDto;
    path?: never;
    query?: never;
    url: '/api/auth/login';
};

export type AuthControllerLoginErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Unauthorized - Invalid credentials
     */
    401: {
        statusCode?: number;
        message?: string;
        error?: string;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type AuthControllerLoginError = AuthControllerLoginErrors[keyof AuthControllerLoginErrors];

export type AuthControllerLoginResponses = {
    /**
     * Access token for further requests
     */
    default: LoginResponseDto;
};

export type AuthControllerLoginResponse = AuthControllerLoginResponses[keyof AuthControllerLoginResponses];

export type AuthControllerRegisterData = {
    body: RegisterRequestDto;
    path?: never;
    query?: never;
    url: '/api/auth/register';
};

export type AuthControllerRegisterErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Forbidden - Registration is not allowed
     */
    403: {
        statusCode?: number;
        message?: string;
        error?: string;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type AuthControllerRegisterError = AuthControllerRegisterErrors[keyof AuthControllerRegisterErrors];

export type AuthControllerRegisterResponses = {
    /**
     * Access token for further requests
     */
    default: RegisterResponseDto;
};

export type AuthControllerRegisterResponse = AuthControllerRegisterResponses[keyof AuthControllerRegisterResponses];

export type AuthControllerGetStatusData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/auth/status';
};

export type AuthControllerGetStatusErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type AuthControllerGetStatusError = AuthControllerGetStatusErrors[keyof AuthControllerGetStatusErrors];

export type AuthControllerGetStatusResponses = {
    /**
     * Status of the system
     */
    default: GetStatusResponseDto;
};

export type AuthControllerGetStatusResponse = AuthControllerGetStatusResponses[keyof AuthControllerGetStatusResponses];

export type AuthControllerTelegramCallbackData = {
    body: TelegramCallbackRequestDto;
    path?: never;
    query?: never;
    url: '/api/auth/oauth2/tg/callback';
};

export type AuthControllerTelegramCallbackErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type AuthControllerTelegramCallbackError = AuthControllerTelegramCallbackErrors[keyof AuthControllerTelegramCallbackErrors];

export type AuthControllerTelegramCallbackResponses = {
    /**
     * Access token for further requests
     */
    default: TelegramCallbackResponseDto;
};

export type AuthControllerTelegramCallbackResponse = AuthControllerTelegramCallbackResponses[keyof AuthControllerTelegramCallbackResponses];

export type AuthControllerOauth2AuthorizeData = {
    body: OAuth2AuthorizeRequestDto;
    path?: never;
    query?: never;
    url: '/api/auth/oauth2/authorize';
};

export type AuthControllerOauth2AuthorizeErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type AuthControllerOauth2AuthorizeError = AuthControllerOauth2AuthorizeErrors[keyof AuthControllerOauth2AuthorizeErrors];

export type AuthControllerOauth2AuthorizeResponses = {
    /**
     * OAuth2 authorization URL
     */
    default: OAuth2AuthorizeResponseDto;
};

export type AuthControllerOauth2AuthorizeResponse = AuthControllerOauth2AuthorizeResponses[keyof AuthControllerOauth2AuthorizeResponses];

export type AuthControllerOauth2CallbackData = {
    body: OAuth2CallbackRequestDto;
    path?: never;
    query?: never;
    url: '/api/auth/oauth2/callback';
};

export type AuthControllerOauth2CallbackErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type AuthControllerOauth2CallbackError = AuthControllerOauth2CallbackErrors[keyof AuthControllerOauth2CallbackErrors];

export type AuthControllerOauth2CallbackResponses = {
    /**
     * Access token for further requests
     */
    default: OAuth2CallbackResponseDto;
};

export type AuthControllerOauth2CallbackResponse = AuthControllerOauth2CallbackResponses[keyof AuthControllerOauth2CallbackResponses];

export type AuthControllerPasskeyAuthenticationOptionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/auth/passkey/authentication/options';
};

export type AuthControllerPasskeyAuthenticationOptionsErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type AuthControllerPasskeyAuthenticationOptionsError = AuthControllerPasskeyAuthenticationOptionsErrors[keyof AuthControllerPasskeyAuthenticationOptionsErrors];

export type AuthControllerPasskeyAuthenticationOptionsResponses = {
    /**
     * Passkey authentication options
     */
    default: GetPasskeyAuthenticationOptionsResponseDto;
};

export type AuthControllerPasskeyAuthenticationOptionsResponse = AuthControllerPasskeyAuthenticationOptionsResponses[keyof AuthControllerPasskeyAuthenticationOptionsResponses];

export type AuthControllerPasskeyAuthenticationVerifyData = {
    body: VerifyPasskeyAuthenticationRequestDto;
    path?: never;
    query?: never;
    url: '/api/auth/passkey/authentication/verify';
};

export type AuthControllerPasskeyAuthenticationVerifyErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type AuthControllerPasskeyAuthenticationVerifyError = AuthControllerPasskeyAuthenticationVerifyErrors[keyof AuthControllerPasskeyAuthenticationVerifyErrors];

export type AuthControllerPasskeyAuthenticationVerifyResponses = {
    /**
     * JWT access token after successful passkey authentication
     */
    default: VerifyPasskeyAuthenticationResponseDto;
};

export type AuthControllerPasskeyAuthenticationVerifyResponse = AuthControllerPasskeyAuthenticationVerifyResponses[keyof AuthControllerPasskeyAuthenticationVerifyResponses];

export type UsersControllerGetAllUsersData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Page size for pagination
         */
        size?: number;
        /**
         * Offset for pagination
         */
        start?: number;
    };
    url: '/api/users';
};

export type UsersControllerGetAllUsersErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type UsersControllerGetAllUsersError = UsersControllerGetAllUsersErrors[keyof UsersControllerGetAllUsersErrors];

export type UsersControllerGetAllUsersResponses = {
    /**
     * Users fetched successfully
     */
    200: GetAllUsersResponseDto;
};

export type UsersControllerGetAllUsersResponse = UsersControllerGetAllUsersResponses[keyof UsersControllerGetAllUsersResponses];

export type UsersControllerUpdateUserData = {
    body: UpdateUserRequestDto;
    path?: never;
    query?: never;
    url: '/api/users';
};

export type UsersControllerUpdateUserErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type UsersControllerUpdateUserError = UsersControllerUpdateUserErrors[keyof UsersControllerUpdateUserErrors];

export type UsersControllerUpdateUserResponses = {
    /**
     * User updated successfully
     */
    200: UpdateUserResponseDto;
};

export type UsersControllerUpdateUserResponse = UsersControllerUpdateUserResponses[keyof UsersControllerUpdateUserResponses];

export type UsersControllerCreateUserData = {
    body: CreateUserRequestDto;
    path?: never;
    query?: never;
    url: '/api/users';
};

export type UsersControllerCreateUserErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type UsersControllerCreateUserError = UsersControllerCreateUserErrors[keyof UsersControllerCreateUserErrors];

export type UsersControllerCreateUserResponses = {
    /**
     * User created successfully
     */
    201: CreateUserResponseDto;
};

export type UsersControllerCreateUserResponse = UsersControllerCreateUserResponses[keyof UsersControllerCreateUserResponses];

export type UsersControllerDeleteUserData = {
    body?: never;
    path: {
        /**
         * UUID of the user
         */
        uuid: string;
    };
    query?: never;
    url: '/api/users/{uuid}';
};

export type UsersControllerDeleteUserErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * User not found
     */
    404: unknown;
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type UsersControllerDeleteUserError = UsersControllerDeleteUserErrors[keyof UsersControllerDeleteUserErrors];

export type UsersControllerDeleteUserResponses = {
    /**
     * User deleted successfully
     */
    200: DeleteUserResponseDto;
};

export type UsersControllerDeleteUserResponse = UsersControllerDeleteUserResponses[keyof UsersControllerDeleteUserResponses];

export type UsersControllerGetUserByUuidData = {
    body?: never;
    path: {
        /**
         * UUID of the user
         */
        uuid: string;
    };
    query?: never;
    url: '/api/users/{uuid}';
};

export type UsersControllerGetUserByUuidErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * User not found
     */
    404: unknown;
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type UsersControllerGetUserByUuidError = UsersControllerGetUserByUuidErrors[keyof UsersControllerGetUserByUuidErrors];

export type UsersControllerGetUserByUuidResponses = {
    /**
     * User fetched successfully
     */
    200: GetUserByUuidResponseDto;
};

export type UsersControllerGetUserByUuidResponse = UsersControllerGetUserByUuidResponses[keyof UsersControllerGetUserByUuidResponses];

export type UsersControllerGetAllTagsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/users/tags';
};

export type UsersControllerGetAllTagsErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type UsersControllerGetAllTagsError = UsersControllerGetAllTagsErrors[keyof UsersControllerGetAllTagsErrors];

export type UsersControllerGetAllTagsResponses = {
    /**
     * Tags fetched successfully
     */
    200: GetAllTagsResponseDto;
};

export type UsersControllerGetAllTagsResponse = UsersControllerGetAllTagsResponses[keyof UsersControllerGetAllTagsResponses];

export type UsersControllerGetUserAccessibleNodesData = {
    body?: never;
    path: {
        /**
         * UUID of the user
         */
        uuid: string;
    };
    query?: never;
    url: '/api/users/{uuid}/accessible-nodes';
};

export type UsersControllerGetUserAccessibleNodesErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * User not found
     */
    404: unknown;
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type UsersControllerGetUserAccessibleNodesError = UsersControllerGetUserAccessibleNodesErrors[keyof UsersControllerGetUserAccessibleNodesErrors];

export type UsersControllerGetUserAccessibleNodesResponses = {
    /**
     * User accessible nodes fetched successfully
     */
    200: GetUserAccessibleNodesResponseDto;
};

export type UsersControllerGetUserAccessibleNodesResponse = UsersControllerGetUserAccessibleNodesResponses[keyof UsersControllerGetUserAccessibleNodesResponses];

export type UsersControllerGetUserSubscriptionRequestHistoryData = {
    body?: never;
    path: {
        /**
         * UUID of the user
         */
        uuid: string;
    };
    query?: never;
    url: '/api/users/{uuid}/subscription-request-history';
};

export type UsersControllerGetUserSubscriptionRequestHistoryErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * User not found
     */
    404: unknown;
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type UsersControllerGetUserSubscriptionRequestHistoryError = UsersControllerGetUserSubscriptionRequestHistoryErrors[keyof UsersControllerGetUserSubscriptionRequestHistoryErrors];

export type UsersControllerGetUserSubscriptionRequestHistoryResponses = {
    /**
     * User subscription request history fetched successfully
     */
    200: GetUserSubscriptionRequestHistoryResponseDto;
};

export type UsersControllerGetUserSubscriptionRequestHistoryResponse = UsersControllerGetUserSubscriptionRequestHistoryResponses[keyof UsersControllerGetUserSubscriptionRequestHistoryResponses];

export type UsersControllerGetUserByShortUuidData = {
    body?: never;
    path: {
        /**
         * Short UUID of the user
         */
        shortUuid: string;
    };
    query?: never;
    url: '/api/users/by-short-uuid/{shortUuid}';
};

export type UsersControllerGetUserByShortUuidErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * User not found
     */
    404: unknown;
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type UsersControllerGetUserByShortUuidError = UsersControllerGetUserByShortUuidErrors[keyof UsersControllerGetUserByShortUuidErrors];

export type UsersControllerGetUserByShortUuidResponses = {
    /**
     * User fetched successfully
     */
    200: GetUserByShortUuidResponseDto;
};

export type UsersControllerGetUserByShortUuidResponse = UsersControllerGetUserByShortUuidResponses[keyof UsersControllerGetUserByShortUuidResponses];

export type UsersControllerGetUserByUsernameData = {
    body?: never;
    path: {
        /**
         * Username of the user
         */
        username: string;
    };
    query?: never;
    url: '/api/users/by-username/{username}';
};

export type UsersControllerGetUserByUsernameErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * User not found
     */
    404: unknown;
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type UsersControllerGetUserByUsernameError = UsersControllerGetUserByUsernameErrors[keyof UsersControllerGetUserByUsernameErrors];

export type UsersControllerGetUserByUsernameResponses = {
    /**
     * User fetched successfully
     */
    200: GetUserByUsernameResponseDto;
};

export type UsersControllerGetUserByUsernameResponse = UsersControllerGetUserByUsernameResponses[keyof UsersControllerGetUserByUsernameResponses];

export type UsersControllerGetUserByIdData = {
    body?: never;
    path: {
        /**
         * ID of the user
         */
        id: string;
    };
    query?: never;
    url: '/api/users/by-id/{id}';
};

export type UsersControllerGetUserByIdErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * User not found
     */
    404: unknown;
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type UsersControllerGetUserByIdError = UsersControllerGetUserByIdErrors[keyof UsersControllerGetUserByIdErrors];

export type UsersControllerGetUserByIdResponses = {
    /**
     * User fetched successfully
     */
    200: GetUserByIdResponseDto;
};

export type UsersControllerGetUserByIdResponse = UsersControllerGetUserByIdResponses[keyof UsersControllerGetUserByIdResponses];

export type UsersControllerGetUserByTelegramIdData = {
    body?: never;
    path: {
        /**
         * Telegram ID of the user
         */
        telegramId: string;
    };
    query?: never;
    url: '/api/users/by-telegram-id/{telegramId}';
};

export type UsersControllerGetUserByTelegramIdErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type UsersControllerGetUserByTelegramIdError = UsersControllerGetUserByTelegramIdErrors[keyof UsersControllerGetUserByTelegramIdErrors];

export type UsersControllerGetUserByTelegramIdResponses = {
    /**
     * Users fetched successfully
     */
    200: GetUserByTelegramIdResponseDto;
};

export type UsersControllerGetUserByTelegramIdResponse = UsersControllerGetUserByTelegramIdResponses[keyof UsersControllerGetUserByTelegramIdResponses];

export type UsersControllerGetUsersByEmailData = {
    body?: never;
    path: {
        /**
         * Email of the user
         */
        email: string;
    };
    query?: never;
    url: '/api/users/by-email/{email}';
};

export type UsersControllerGetUsersByEmailErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type UsersControllerGetUsersByEmailError = UsersControllerGetUsersByEmailErrors[keyof UsersControllerGetUsersByEmailErrors];

export type UsersControllerGetUsersByEmailResponses = {
    /**
     * Users fetched successfully
     */
    200: GetUserByEmailResponseDto;
};

export type UsersControllerGetUsersByEmailResponse = UsersControllerGetUsersByEmailResponses[keyof UsersControllerGetUsersByEmailResponses];

export type UsersControllerGetUsersByTagData = {
    body?: never;
    path: {
        /**
         * Tag of the user
         */
        tag: string;
    };
    query?: never;
    url: '/api/users/by-tag/{tag}';
};

export type UsersControllerGetUsersByTagErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type UsersControllerGetUsersByTagError = UsersControllerGetUsersByTagErrors[keyof UsersControllerGetUsersByTagErrors];

export type UsersControllerGetUsersByTagResponses = {
    /**
     * Users fetched successfully
     */
    200: GetUserByTagResponseDto;
};

export type UsersControllerGetUsersByTagResponse = UsersControllerGetUsersByTagResponses[keyof UsersControllerGetUsersByTagResponses];

export type UsersControllerRevokeUserSubscriptionData = {
    body: RevokeUserSubscriptionBodyDto;
    path: {
        /**
         * UUID of the user
         */
        uuid: string;
    };
    query?: never;
    url: '/api/users/{uuid}/actions/revoke';
};

export type UsersControllerRevokeUserSubscriptionErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * User not found
     */
    404: unknown;
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type UsersControllerRevokeUserSubscriptionError = UsersControllerRevokeUserSubscriptionErrors[keyof UsersControllerRevokeUserSubscriptionErrors];

export type UsersControllerRevokeUserSubscriptionResponses = {
    /**
     * User subscription revoked successfully
     */
    200: RevokeUserSubscriptionResponseDto;
};

export type UsersControllerRevokeUserSubscriptionResponse = UsersControllerRevokeUserSubscriptionResponses[keyof UsersControllerRevokeUserSubscriptionResponses];

export type UsersControllerDisableUserData = {
    body?: never;
    path: {
        /**
         * UUID of the user
         */
        uuid: string;
    };
    query?: never;
    url: '/api/users/{uuid}/actions/disable';
};

export type UsersControllerDisableUserErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * User not found
     */
    404: unknown;
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type UsersControllerDisableUserError = UsersControllerDisableUserErrors[keyof UsersControllerDisableUserErrors];

export type UsersControllerDisableUserResponses = {
    /**
     * User disabled successfully
     */
    200: DisableUserResponseDto;
};

export type UsersControllerDisableUserResponse = UsersControllerDisableUserResponses[keyof UsersControllerDisableUserResponses];

export type UsersControllerEnableUserData = {
    body?: never;
    path: {
        /**
         * UUID of the user
         */
        uuid: string;
    };
    query?: never;
    url: '/api/users/{uuid}/actions/enable';
};

export type UsersControllerEnableUserErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * User not found
     */
    404: unknown;
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type UsersControllerEnableUserError = UsersControllerEnableUserErrors[keyof UsersControllerEnableUserErrors];

export type UsersControllerEnableUserResponses = {
    /**
     * User enabled successfully
     */
    200: EnableUserResponseDto;
};

export type UsersControllerEnableUserResponse = UsersControllerEnableUserResponses[keyof UsersControllerEnableUserResponses];

export type UsersControllerResetUserTrafficData = {
    body?: never;
    path: {
        /**
         * UUID of the user
         */
        uuid: string;
    };
    query?: never;
    url: '/api/users/{uuid}/actions/reset-traffic';
};

export type UsersControllerResetUserTrafficErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * User not found
     */
    404: unknown;
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type UsersControllerResetUserTrafficError = UsersControllerResetUserTrafficErrors[keyof UsersControllerResetUserTrafficErrors];

export type UsersControllerResetUserTrafficResponses = {
    /**
     * User traffic reset successfully
     */
    200: ResetUserTrafficResponseDto;
};

export type UsersControllerResetUserTrafficResponse = UsersControllerResetUserTrafficResponses[keyof UsersControllerResetUserTrafficResponses];

export type UsersBulkActionsControllerBulkDeleteUsersByStatusData = {
    body: BulkDeleteUsersByStatusRequestDto;
    path?: never;
    query?: never;
    url: '/api/users/bulk/delete-by-status';
};

export type UsersBulkActionsControllerBulkDeleteUsersByStatusErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type UsersBulkActionsControllerBulkDeleteUsersByStatusError = UsersBulkActionsControllerBulkDeleteUsersByStatusErrors[keyof UsersBulkActionsControllerBulkDeleteUsersByStatusErrors];

export type UsersBulkActionsControllerBulkDeleteUsersByStatusResponses = {
    /**
     * Users deleted successfully
     */
    200: BulkDeleteUsersByStatusResponseDto;
};

export type UsersBulkActionsControllerBulkDeleteUsersByStatusResponse = UsersBulkActionsControllerBulkDeleteUsersByStatusResponses[keyof UsersBulkActionsControllerBulkDeleteUsersByStatusResponses];

export type UsersBulkActionsControllerBulkDeleteUsersData = {
    body: BulkDeleteUsersRequestDto;
    path?: never;
    query?: never;
    url: '/api/users/bulk/delete';
};

export type UsersBulkActionsControllerBulkDeleteUsersErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type UsersBulkActionsControllerBulkDeleteUsersError = UsersBulkActionsControllerBulkDeleteUsersErrors[keyof UsersBulkActionsControllerBulkDeleteUsersErrors];

export type UsersBulkActionsControllerBulkDeleteUsersResponses = {
    /**
     * Users deleted successfully
     */
    200: BulkDeleteUsersResponseDto;
};

export type UsersBulkActionsControllerBulkDeleteUsersResponse = UsersBulkActionsControllerBulkDeleteUsersResponses[keyof UsersBulkActionsControllerBulkDeleteUsersResponses];

export type UsersBulkActionsControllerBulkRevokeUsersSubscriptionData = {
    body: BulkRevokeUsersSubscriptionRequestDto;
    path?: never;
    query?: never;
    url: '/api/users/bulk/revoke-subscription';
};

export type UsersBulkActionsControllerBulkRevokeUsersSubscriptionErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type UsersBulkActionsControllerBulkRevokeUsersSubscriptionError = UsersBulkActionsControllerBulkRevokeUsersSubscriptionErrors[keyof UsersBulkActionsControllerBulkRevokeUsersSubscriptionErrors];

export type UsersBulkActionsControllerBulkRevokeUsersSubscriptionResponses = {
    /**
     * Users subscription revoked successfully
     */
    200: BulkRevokeUsersSubscriptionResponseDto;
};

export type UsersBulkActionsControllerBulkRevokeUsersSubscriptionResponse = UsersBulkActionsControllerBulkRevokeUsersSubscriptionResponses[keyof UsersBulkActionsControllerBulkRevokeUsersSubscriptionResponses];

export type UsersBulkActionsControllerBulkResetUserTrafficData = {
    body: BulkResetTrafficUsersRequestDto;
    path?: never;
    query?: never;
    url: '/api/users/bulk/reset-traffic';
};

export type UsersBulkActionsControllerBulkResetUserTrafficErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type UsersBulkActionsControllerBulkResetUserTrafficError = UsersBulkActionsControllerBulkResetUserTrafficErrors[keyof UsersBulkActionsControllerBulkResetUserTrafficErrors];

export type UsersBulkActionsControllerBulkResetUserTrafficResponses = {
    /**
     * Users traffic reset successfully
     */
    200: BulkResetTrafficUsersResponseDto;
};

export type UsersBulkActionsControllerBulkResetUserTrafficResponse = UsersBulkActionsControllerBulkResetUserTrafficResponses[keyof UsersBulkActionsControllerBulkResetUserTrafficResponses];

export type UsersBulkActionsControllerBulkUpdateUsersData = {
    body: BulkUpdateUsersRequestDto;
    path?: never;
    query?: never;
    url: '/api/users/bulk/update';
};

export type UsersBulkActionsControllerBulkUpdateUsersErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type UsersBulkActionsControllerBulkUpdateUsersError = UsersBulkActionsControllerBulkUpdateUsersErrors[keyof UsersBulkActionsControllerBulkUpdateUsersErrors];

export type UsersBulkActionsControllerBulkUpdateUsersResponses = {
    /**
     * Users updated successfully
     */
    200: BulkUpdateUsersResponseDto;
};

export type UsersBulkActionsControllerBulkUpdateUsersResponse = UsersBulkActionsControllerBulkUpdateUsersResponses[keyof UsersBulkActionsControllerBulkUpdateUsersResponses];

export type UsersBulkActionsControllerBulkUpdateUsersInternalSquadsData = {
    body: BulkUpdateUsersSquadsRequestDto;
    path?: never;
    query?: never;
    url: '/api/users/bulk/update-squads';
};

export type UsersBulkActionsControllerBulkUpdateUsersInternalSquadsErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type UsersBulkActionsControllerBulkUpdateUsersInternalSquadsError = UsersBulkActionsControllerBulkUpdateUsersInternalSquadsErrors[keyof UsersBulkActionsControllerBulkUpdateUsersInternalSquadsErrors];

export type UsersBulkActionsControllerBulkUpdateUsersInternalSquadsResponses = {
    /**
     * Internal squads updated successfully
     */
    200: BulkUpdateUsersSquadsResponseDto;
};

export type UsersBulkActionsControllerBulkUpdateUsersInternalSquadsResponse = UsersBulkActionsControllerBulkUpdateUsersInternalSquadsResponses[keyof UsersBulkActionsControllerBulkUpdateUsersInternalSquadsResponses];

export type UsersBulkActionsControllerBulkExtendExpirationDateData = {
    body: BulkExtendExpirationDateRequestDto;
    path?: never;
    query?: never;
    url: '/api/users/bulk/extend-expiration-date';
};

export type UsersBulkActionsControllerBulkExtendExpirationDateErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type UsersBulkActionsControllerBulkExtendExpirationDateError = UsersBulkActionsControllerBulkExtendExpirationDateErrors[keyof UsersBulkActionsControllerBulkExtendExpirationDateErrors];

export type UsersBulkActionsControllerBulkExtendExpirationDateResponses = {
    /**
     * Users expiration date extended successfully
     */
    200: BulkExtendExpirationDateResponseDto;
};

export type UsersBulkActionsControllerBulkExtendExpirationDateResponse = UsersBulkActionsControllerBulkExtendExpirationDateResponses[keyof UsersBulkActionsControllerBulkExtendExpirationDateResponses];

export type UsersBulkActionsControllerBulkUpdateAllUsersData = {
    body: BulkAllUpdateUsersRequestDto;
    path?: never;
    query?: never;
    url: '/api/users/bulk/all/update';
};

export type UsersBulkActionsControllerBulkUpdateAllUsersErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type UsersBulkActionsControllerBulkUpdateAllUsersError = UsersBulkActionsControllerBulkUpdateAllUsersErrors[keyof UsersBulkActionsControllerBulkUpdateAllUsersErrors];

export type UsersBulkActionsControllerBulkUpdateAllUsersResponses = {
    /**
     * All users updated successfully
     */
    200: BulkAllUpdateUsersResponseDto;
};

export type UsersBulkActionsControllerBulkUpdateAllUsersResponse = UsersBulkActionsControllerBulkUpdateAllUsersResponses[keyof UsersBulkActionsControllerBulkUpdateAllUsersResponses];

export type UsersBulkActionsControllerBulkAllResetUserTrafficData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/users/bulk/all/reset-traffic';
};

export type UsersBulkActionsControllerBulkAllResetUserTrafficErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type UsersBulkActionsControllerBulkAllResetUserTrafficError = UsersBulkActionsControllerBulkAllResetUserTrafficErrors[keyof UsersBulkActionsControllerBulkAllResetUserTrafficErrors];

export type UsersBulkActionsControllerBulkAllResetUserTrafficResponses = {
    /**
     * All users traffic reset successfully
     */
    200: BulkAllResetTrafficUsersResponseDto;
};

export type UsersBulkActionsControllerBulkAllResetUserTrafficResponse = UsersBulkActionsControllerBulkAllResetUserTrafficResponses[keyof UsersBulkActionsControllerBulkAllResetUserTrafficResponses];

export type UsersBulkActionsControllerBulkAllExtendExpirationDateData = {
    body: BulkAllExtendExpirationDateRequestDto;
    path?: never;
    query?: never;
    url: '/api/users/bulk/all/extend-expiration-date';
};

export type UsersBulkActionsControllerBulkAllExtendExpirationDateErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type UsersBulkActionsControllerBulkAllExtendExpirationDateError = UsersBulkActionsControllerBulkAllExtendExpirationDateErrors[keyof UsersBulkActionsControllerBulkAllExtendExpirationDateErrors];

export type UsersBulkActionsControllerBulkAllExtendExpirationDateResponses = {
    /**
     * All users expiration date extended successfully
     */
    200: BulkAllExtendExpirationDateResponseDto;
};

export type UsersBulkActionsControllerBulkAllExtendExpirationDateResponse = UsersBulkActionsControllerBulkAllExtendExpirationDateResponses[keyof UsersBulkActionsControllerBulkAllExtendExpirationDateResponses];

export type UsersStatsControllerGetUserUsageByRangeData = {
    body?: never;
    path: {
        /**
         * UUID of the user
         */
        uuid: string;
    };
    query: {
        /**
         * Start date
         */
        start: string;
        /**
         * End date
         */
        end: string;
    };
    url: '/api/users/stats/usage/{uuid}/range';
};

export type UsersStatsControllerGetUserUsageByRangeErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * User not found
     */
    404: unknown;
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type UsersStatsControllerGetUserUsageByRangeError = UsersStatsControllerGetUserUsageByRangeErrors[keyof UsersStatsControllerGetUserUsageByRangeErrors];

export type UsersStatsControllerGetUserUsageByRangeResponses = {
    /**
     * User usage by range fetched successfully
     */
    200: GetUserUsageByRangeResponseDto;
};

export type UsersStatsControllerGetUserUsageByRangeResponse = UsersStatsControllerGetUserUsageByRangeResponses[keyof UsersStatsControllerGetUserUsageByRangeResponses];

export type SubscriptionControllerGetSubscriptionInfoByShortUuidData = {
    body?: never;
    path: {
        /**
         * Short UUID of the user
         */
        shortUuid: string;
    };
    query?: never;
    url: '/api/sub/{shortUuid}/info';
};

export type SubscriptionControllerGetSubscriptionInfoByShortUuidErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type SubscriptionControllerGetSubscriptionInfoByShortUuidError = SubscriptionControllerGetSubscriptionInfoByShortUuidErrors[keyof SubscriptionControllerGetSubscriptionInfoByShortUuidErrors];

export type SubscriptionControllerGetSubscriptionInfoByShortUuidResponses = {
    /**
     * Subscription info fetched successfully
     */
    200: GetSubscriptionInfoResponseDto;
};

export type SubscriptionControllerGetSubscriptionInfoByShortUuidResponse = SubscriptionControllerGetSubscriptionInfoByShortUuidResponses[keyof SubscriptionControllerGetSubscriptionInfoByShortUuidResponses];

export type SubscriptionControllerGetSubscriptionData = {
    body?: never;
    path: {
        /**
         * Short UUID of the user
         */
        shortUuid: string;
    };
    query?: never;
    url: '/api/sub/{shortUuid}';
};

export type SubscriptionControllerGetSubscriptionResponses = {
    200: unknown;
};

export type SubscriptionControllerGetSubscriptionByClientTypeData = {
    body?: never;
    path: {
        /**
         * Client type
         */
        clientType: 'stash' | 'singbox' | 'mihomo' | 'json' | 'v2ray-json' | 'clash';
        /**
         * Short UUID of the user
         */
        shortUuid: string;
    };
    query?: never;
    url: '/api/sub/{shortUuid}/{clientType}';
};

export type SubscriptionControllerGetSubscriptionByClientTypeResponses = {
    200: unknown;
};

export type SubscriptionControllerGetSubscriptionWithTypeData = {
    body?: never;
    path: {
        /**
         * Subscription type (required if encodedTag is provided). Only SS is supported for now.
         */
        type: string;
        /**
         * Base64 encoded tag for Outline config. This paramter is optional. It is required only when type=ss.
         */
        encodedTag: string;
        /**
         * Short UUID of the user
         */
        shortUuid: string;
    };
    query?: never;
    url: '/api/sub/outline/{shortUuid}/{type}/{encodedTag}';
};

export type SubscriptionControllerGetSubscriptionWithTypeResponses = {
    200: unknown;
};

export type SubscriptionsControllerGetAllSubscriptionsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Number of subscriptions to return, no more than 500
         */
        size?: number;
        /**
         * Start index (offset) of the users to return, default is 0
         */
        start?: number;
    };
    url: '/api/subscriptions';
};

export type SubscriptionsControllerGetAllSubscriptionsErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type SubscriptionsControllerGetAllSubscriptionsError = SubscriptionsControllerGetAllSubscriptionsErrors[keyof SubscriptionsControllerGetAllSubscriptionsErrors];

export type SubscriptionsControllerGetAllSubscriptionsResponses = {
    /**
     * Users fetched successfully
     */
    200: GetAllSubscriptionsResponseDto;
};

export type SubscriptionsControllerGetAllSubscriptionsResponse = SubscriptionsControllerGetAllSubscriptionsResponses[keyof SubscriptionsControllerGetAllSubscriptionsResponses];

export type SubscriptionsControllerGetSubscriptionByUsernameData = {
    body?: never;
    path: {
        /**
         * Username of the user
         */
        username: string;
    };
    query?: never;
    url: '/api/subscriptions/by-username/{username}';
};

export type SubscriptionsControllerGetSubscriptionByUsernameErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * User not found
     */
    404: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type SubscriptionsControllerGetSubscriptionByUsernameError = SubscriptionsControllerGetSubscriptionByUsernameErrors[keyof SubscriptionsControllerGetSubscriptionByUsernameErrors];

export type SubscriptionsControllerGetSubscriptionByUsernameResponses = {
    /**
     * Subscription fetched successfully
     */
    200: GetSubscriptionByUsernameResponseDto;
};

export type SubscriptionsControllerGetSubscriptionByUsernameResponse = SubscriptionsControllerGetSubscriptionByUsernameResponses[keyof SubscriptionsControllerGetSubscriptionByUsernameResponses];

export type SubscriptionsControllerGetSubscriptionByShortUuidProtectedData = {
    body?: never;
    path: {
        /**
         * Short uuid of the user
         */
        shortUuid: string;
    };
    query?: never;
    url: '/api/subscriptions/by-short-uuid/{shortUuid}';
};

export type SubscriptionsControllerGetSubscriptionByShortUuidProtectedErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * User not found
     */
    404: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type SubscriptionsControllerGetSubscriptionByShortUuidProtectedError = SubscriptionsControllerGetSubscriptionByShortUuidProtectedErrors[keyof SubscriptionsControllerGetSubscriptionByShortUuidProtectedErrors];

export type SubscriptionsControllerGetSubscriptionByShortUuidProtectedResponses = {
    /**
     * Subscription fetched successfully
     */
    200: GetSubscriptionByShortUuidProtectedResponseDto;
};

export type SubscriptionsControllerGetSubscriptionByShortUuidProtectedResponse = SubscriptionsControllerGetSubscriptionByShortUuidProtectedResponses[keyof SubscriptionsControllerGetSubscriptionByShortUuidProtectedResponses];

export type SubscriptionsControllerGetSubscriptionByUuidData = {
    body?: never;
    path: {
        /**
         * Uuid of the user
         */
        uuid: string;
    };
    query?: never;
    url: '/api/subscriptions/by-uuid/{uuid}';
};

export type SubscriptionsControllerGetSubscriptionByUuidErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * User not found
     */
    404: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type SubscriptionsControllerGetSubscriptionByUuidError = SubscriptionsControllerGetSubscriptionByUuidErrors[keyof SubscriptionsControllerGetSubscriptionByUuidErrors];

export type SubscriptionsControllerGetSubscriptionByUuidResponses = {
    /**
     * Subscription fetched successfully
     */
    200: GetSubscriptionByUuidResponseDto;
};

export type SubscriptionsControllerGetSubscriptionByUuidResponse = SubscriptionsControllerGetSubscriptionByUuidResponses[keyof SubscriptionsControllerGetSubscriptionByUuidResponses];

export type SubscriptionsControllerGetRawSubscriptionByShortUuidData = {
    body?: never;
    path: {
        /**
         * Short UUID of the user
         */
        shortUuid: string;
    };
    query?: {
        /**
         * Include disabled hosts in the subscription. Default is false.
         */
        withDisabledHosts?: boolean;
    };
    url: '/api/subscriptions/by-short-uuid/{shortUuid}/raw';
};

export type SubscriptionsControllerGetRawSubscriptionByShortUuidErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type SubscriptionsControllerGetRawSubscriptionByShortUuidError = SubscriptionsControllerGetRawSubscriptionByShortUuidErrors[keyof SubscriptionsControllerGetRawSubscriptionByShortUuidErrors];

export type SubscriptionsControllerGetRawSubscriptionByShortUuidResponses = {
    /**
     * Raw subscription fetched successfully
     */
    200: GetRawSubscriptionByShortUuidResponseDto;
};

export type SubscriptionsControllerGetRawSubscriptionByShortUuidResponse = SubscriptionsControllerGetRawSubscriptionByShortUuidResponses[keyof SubscriptionsControllerGetRawSubscriptionByShortUuidResponses];

export type SubscriptionTemplateControllerGetAllTemplatesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/subscription-templates';
};

export type SubscriptionTemplateControllerGetAllTemplatesErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type SubscriptionTemplateControllerGetAllTemplatesError = SubscriptionTemplateControllerGetAllTemplatesErrors[keyof SubscriptionTemplateControllerGetAllTemplatesErrors];

export type SubscriptionTemplateControllerGetAllTemplatesResponses = {
    /**
     * Templates retrieved successfully
     */
    200: GetTemplatesResponseDto;
};

export type SubscriptionTemplateControllerGetAllTemplatesResponse = SubscriptionTemplateControllerGetAllTemplatesResponses[keyof SubscriptionTemplateControllerGetAllTemplatesResponses];

export type SubscriptionTemplateControllerUpdateTemplateData = {
    body: UpdateTemplateRequestDto;
    path?: never;
    query?: never;
    url: '/api/subscription-templates';
};

export type SubscriptionTemplateControllerUpdateTemplateErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type SubscriptionTemplateControllerUpdateTemplateError = SubscriptionTemplateControllerUpdateTemplateErrors[keyof SubscriptionTemplateControllerUpdateTemplateErrors];

export type SubscriptionTemplateControllerUpdateTemplateResponses = {
    /**
     * Template updated successfully
     */
    200: UpdateTemplateResponseDto;
};

export type SubscriptionTemplateControllerUpdateTemplateResponse = SubscriptionTemplateControllerUpdateTemplateResponses[keyof SubscriptionTemplateControllerUpdateTemplateResponses];

export type SubscriptionTemplateControllerCreateTemplateData = {
    body: CreateSubscriptionTemplateRequestDto;
    path?: never;
    query?: never;
    url: '/api/subscription-templates';
};

export type SubscriptionTemplateControllerCreateTemplateErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type SubscriptionTemplateControllerCreateTemplateError = SubscriptionTemplateControllerCreateTemplateErrors[keyof SubscriptionTemplateControllerCreateTemplateErrors];

export type SubscriptionTemplateControllerCreateTemplateResponses = {
    /**
     * Template created successfully
     */
    200: CreateSubscriptionTemplateResponseDto;
};

export type SubscriptionTemplateControllerCreateTemplateResponse = SubscriptionTemplateControllerCreateTemplateResponses[keyof SubscriptionTemplateControllerCreateTemplateResponses];

export type SubscriptionTemplateControllerDeleteTemplateData = {
    body?: never;
    path: {
        /**
         * Template UUID
         */
        uuid: string;
    };
    query?: never;
    url: '/api/subscription-templates/{uuid}';
};

export type SubscriptionTemplateControllerDeleteTemplateErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type SubscriptionTemplateControllerDeleteTemplateError = SubscriptionTemplateControllerDeleteTemplateErrors[keyof SubscriptionTemplateControllerDeleteTemplateErrors];

export type SubscriptionTemplateControllerDeleteTemplateResponses = {
    /**
     * Template deleted successfully
     */
    200: DeleteSubscriptionTemplateResponseDto;
};

export type SubscriptionTemplateControllerDeleteTemplateResponse = SubscriptionTemplateControllerDeleteTemplateResponses[keyof SubscriptionTemplateControllerDeleteTemplateResponses];

export type SubscriptionTemplateControllerGetTemplateByUuidData = {
    body?: never;
    path: {
        /**
         * Template UUID
         */
        uuid: string;
    };
    query?: never;
    url: '/api/subscription-templates/{uuid}';
};

export type SubscriptionTemplateControllerGetTemplateByUuidErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type SubscriptionTemplateControllerGetTemplateByUuidError = SubscriptionTemplateControllerGetTemplateByUuidErrors[keyof SubscriptionTemplateControllerGetTemplateByUuidErrors];

export type SubscriptionTemplateControllerGetTemplateByUuidResponses = {
    /**
     * Template retrieved successfully
     */
    200: GetTemplateResponseDto;
};

export type SubscriptionTemplateControllerGetTemplateByUuidResponse = SubscriptionTemplateControllerGetTemplateByUuidResponses[keyof SubscriptionTemplateControllerGetTemplateByUuidResponses];

export type SubscriptionTemplateControllerReorderSubscriptionTemplatesData = {
    body: ReorderSubscriptionTemplatesRequestDto;
    path?: never;
    query?: never;
    url: '/api/subscription-templates/actions/reorder';
};

export type SubscriptionTemplateControllerReorderSubscriptionTemplatesErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type SubscriptionTemplateControllerReorderSubscriptionTemplatesError = SubscriptionTemplateControllerReorderSubscriptionTemplatesErrors[keyof SubscriptionTemplateControllerReorderSubscriptionTemplatesErrors];

export type SubscriptionTemplateControllerReorderSubscriptionTemplatesResponses = {
    /**
     * Subscription templates reordered successfully
     */
    200: ReorderSubscriptionTemplatesResponseDto;
};

export type SubscriptionTemplateControllerReorderSubscriptionTemplatesResponse = SubscriptionTemplateControllerReorderSubscriptionTemplatesResponses[keyof SubscriptionTemplateControllerReorderSubscriptionTemplatesResponses];

export type ApiTokensControllerFindAllData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/tokens';
};

export type ApiTokensControllerFindAllErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type ApiTokensControllerFindAllError = ApiTokensControllerFindAllErrors[keyof ApiTokensControllerFindAllErrors];

export type ApiTokensControllerFindAllResponses = {
    /**
     * Tokens fetched successfully
     */
    200: FindAllApiTokensResponseDto;
};

export type ApiTokensControllerFindAllResponse = ApiTokensControllerFindAllResponses[keyof ApiTokensControllerFindAllResponses];

export type ApiTokensControllerCreateData = {
    body: CreateApiTokenRequestDto;
    path?: never;
    query?: never;
    url: '/api/tokens';
};

export type ApiTokensControllerCreateErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type ApiTokensControllerCreateError = ApiTokensControllerCreateErrors[keyof ApiTokensControllerCreateErrors];

export type ApiTokensControllerCreateResponses = {
    /**
     * Token created successfully
     */
    201: CreateApiTokenResponseDto;
};

export type ApiTokensControllerCreateResponse = ApiTokensControllerCreateResponses[keyof ApiTokensControllerCreateResponses];

export type ApiTokensControllerDeleteData = {
    body?: never;
    path: {
        /**
         * UUID of the API token
         */
        uuid: string;
    };
    query?: never;
    url: '/api/tokens/{uuid}';
};

export type ApiTokensControllerDeleteErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type ApiTokensControllerDeleteError = ApiTokensControllerDeleteErrors[keyof ApiTokensControllerDeleteErrors];

export type ApiTokensControllerDeleteResponses = {
    /**
     * Token deleted successfully
     */
    200: DeleteApiTokenResponseDto;
};

export type ApiTokensControllerDeleteResponse = ApiTokensControllerDeleteResponses[keyof ApiTokensControllerDeleteResponses];

export type ConfigProfileControllerGetConfigProfilesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/config-profiles';
};

export type ConfigProfileControllerGetConfigProfilesErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type ConfigProfileControllerGetConfigProfilesError = ConfigProfileControllerGetConfigProfilesErrors[keyof ConfigProfileControllerGetConfigProfilesErrors];

export type ConfigProfileControllerGetConfigProfilesResponses = {
    /**
     * Config profiles retrieved successfully
     */
    200: GetConfigProfilesResponseDto;
};

export type ConfigProfileControllerGetConfigProfilesResponse = ConfigProfileControllerGetConfigProfilesResponses[keyof ConfigProfileControllerGetConfigProfilesResponses];

export type ConfigProfileControllerUpdateConfigProfileData = {
    body: UpdateConfigProfileRequestDto;
    path?: never;
    query?: never;
    url: '/api/config-profiles';
};

export type ConfigProfileControllerUpdateConfigProfileErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Config profile not found
     */
    404: unknown;
    /**
     * Config profile name already exists or inbound tags are not unique. Inbound tags must be unique in global scope.
     */
    409: unknown;
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type ConfigProfileControllerUpdateConfigProfileError = ConfigProfileControllerUpdateConfigProfileErrors[keyof ConfigProfileControllerUpdateConfigProfileErrors];

export type ConfigProfileControllerUpdateConfigProfileResponses = {
    /**
     * Config profile updated successfully
     */
    200: UpdateConfigProfileResponseDto;
};

export type ConfigProfileControllerUpdateConfigProfileResponse = ConfigProfileControllerUpdateConfigProfileResponses[keyof ConfigProfileControllerUpdateConfigProfileResponses];

export type ConfigProfileControllerCreateConfigProfileData = {
    body: CreateConfigProfileRequestDto;
    path?: never;
    query?: never;
    url: '/api/config-profiles';
};

export type ConfigProfileControllerCreateConfigProfileErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Config profile name already exists or inbound tags are not unique. Inbound tags must be unique in global scope.
     */
    409: unknown;
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type ConfigProfileControllerCreateConfigProfileError = ConfigProfileControllerCreateConfigProfileErrors[keyof ConfigProfileControllerCreateConfigProfileErrors];

export type ConfigProfileControllerCreateConfigProfileResponses = {
    /**
     * Config profile created successfully
     */
    201: CreateConfigProfileResponseDto;
};

export type ConfigProfileControllerCreateConfigProfileResponse = ConfigProfileControllerCreateConfigProfileResponses[keyof ConfigProfileControllerCreateConfigProfileResponses];

export type ConfigProfileControllerGetAllInboundsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/config-profiles/inbounds';
};

export type ConfigProfileControllerGetAllInboundsErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type ConfigProfileControllerGetAllInboundsError = ConfigProfileControllerGetAllInboundsErrors[keyof ConfigProfileControllerGetAllInboundsErrors];

export type ConfigProfileControllerGetAllInboundsResponses = {
    /**
     * Inbounds retrieved successfully
     */
    200: GetAllInboundsResponseDto;
};

export type ConfigProfileControllerGetAllInboundsResponse = ConfigProfileControllerGetAllInboundsResponses[keyof ConfigProfileControllerGetAllInboundsResponses];

export type ConfigProfileControllerGetInboundsByProfileUuidData = {
    body?: never;
    path: {
        uuid: string;
    };
    query?: never;
    url: '/api/config-profiles/{uuid}/inbounds';
};

export type ConfigProfileControllerGetInboundsByProfileUuidErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Config profile not found
     */
    404: unknown;
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type ConfigProfileControllerGetInboundsByProfileUuidError = ConfigProfileControllerGetInboundsByProfileUuidErrors[keyof ConfigProfileControllerGetInboundsByProfileUuidErrors];

export type ConfigProfileControllerGetInboundsByProfileUuidResponses = {
    /**
     * Inbounds retrieved successfully
     */
    200: GetInboundsByProfileUuidResponseDto;
};

export type ConfigProfileControllerGetInboundsByProfileUuidResponse = ConfigProfileControllerGetInboundsByProfileUuidResponses[keyof ConfigProfileControllerGetInboundsByProfileUuidResponses];

export type ConfigProfileControllerDeleteConfigProfileByUuidData = {
    body?: never;
    path: {
        uuid: string;
    };
    query?: never;
    url: '/api/config-profiles/{uuid}';
};

export type ConfigProfileControllerDeleteConfigProfileByUuidErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Config profile not found
     */
    404: unknown;
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type ConfigProfileControllerDeleteConfigProfileByUuidError = ConfigProfileControllerDeleteConfigProfileByUuidErrors[keyof ConfigProfileControllerDeleteConfigProfileByUuidErrors];

export type ConfigProfileControllerDeleteConfigProfileByUuidResponses = {
    /**
     * Config profile deleted successfully
     */
    200: DeleteConfigProfileResponseDto;
};

export type ConfigProfileControllerDeleteConfigProfileByUuidResponse = ConfigProfileControllerDeleteConfigProfileByUuidResponses[keyof ConfigProfileControllerDeleteConfigProfileByUuidResponses];

export type ConfigProfileControllerGetConfigProfileByUuidData = {
    body?: never;
    path: {
        uuid: string;
    };
    query?: never;
    url: '/api/config-profiles/{uuid}';
};

export type ConfigProfileControllerGetConfigProfileByUuidErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Config profile not found
     */
    404: unknown;
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type ConfigProfileControllerGetConfigProfileByUuidError = ConfigProfileControllerGetConfigProfileByUuidErrors[keyof ConfigProfileControllerGetConfigProfileByUuidErrors];

export type ConfigProfileControllerGetConfigProfileByUuidResponses = {
    /**
     * Config profile retrieved successfully
     */
    200: GetConfigProfileByUuidResponseDto;
};

export type ConfigProfileControllerGetConfigProfileByUuidResponse = ConfigProfileControllerGetConfigProfileByUuidResponses[keyof ConfigProfileControllerGetConfigProfileByUuidResponses];

export type ConfigProfileControllerGetComputedConfigProfileByUuidData = {
    body?: never;
    path: {
        uuid: string;
    };
    query?: never;
    url: '/api/config-profiles/{uuid}/computed-config';
};

export type ConfigProfileControllerGetComputedConfigProfileByUuidErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Config profile not found
     */
    404: unknown;
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type ConfigProfileControllerGetComputedConfigProfileByUuidError = ConfigProfileControllerGetComputedConfigProfileByUuidErrors[keyof ConfigProfileControllerGetComputedConfigProfileByUuidErrors];

export type ConfigProfileControllerGetComputedConfigProfileByUuidResponses = {
    /**
     * Computed config profile retrieved successfully
     */
    200: GetComputedConfigProfileByUuidResponseDto;
};

export type ConfigProfileControllerGetComputedConfigProfileByUuidResponse = ConfigProfileControllerGetComputedConfigProfileByUuidResponses[keyof ConfigProfileControllerGetComputedConfigProfileByUuidResponses];

export type ConfigProfileControllerReorderConfigProfilesData = {
    body: ReorderConfigProfilesRequestDto;
    path?: never;
    query?: never;
    url: '/api/config-profiles/actions/reorder';
};

export type ConfigProfileControllerReorderConfigProfilesErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type ConfigProfileControllerReorderConfigProfilesError = ConfigProfileControllerReorderConfigProfilesErrors[keyof ConfigProfileControllerReorderConfigProfilesErrors];

export type ConfigProfileControllerReorderConfigProfilesResponses = {
    /**
     * Config profiles reordered successfully
     */
    200: ReorderConfigProfilesResponseDto;
};

export type ConfigProfileControllerReorderConfigProfilesResponse = ConfigProfileControllerReorderConfigProfilesResponses[keyof ConfigProfileControllerReorderConfigProfilesResponses];

export type SnippetsControllerDeleteSnippetByNameData = {
    body: DeleteSnippetRequestDto;
    path?: never;
    query?: never;
    url: '/api/snippets';
};

export type SnippetsControllerDeleteSnippetByNameErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Snippet not found
     */
    404: unknown;
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type SnippetsControllerDeleteSnippetByNameError = SnippetsControllerDeleteSnippetByNameErrors[keyof SnippetsControllerDeleteSnippetByNameErrors];

export type SnippetsControllerDeleteSnippetByNameResponses = {
    /**
     * Snippet deleted successfully
     */
    200: DeleteSnippetResponseDto;
};

export type SnippetsControllerDeleteSnippetByNameResponse = SnippetsControllerDeleteSnippetByNameResponses[keyof SnippetsControllerDeleteSnippetByNameResponses];

export type SnippetsControllerGetSnippetsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/snippets';
};

export type SnippetsControllerGetSnippetsErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type SnippetsControllerGetSnippetsError = SnippetsControllerGetSnippetsErrors[keyof SnippetsControllerGetSnippetsErrors];

export type SnippetsControllerGetSnippetsResponses = {
    /**
     * Snippets retrieved successfully
     */
    200: GetSnippetsResponseDto;
};

export type SnippetsControllerGetSnippetsResponse = SnippetsControllerGetSnippetsResponses[keyof SnippetsControllerGetSnippetsResponses];

export type SnippetsControllerUpdateSnippetData = {
    body: UpdateSnippetRequestDto;
    path?: never;
    query?: never;
    url: '/api/snippets';
};

export type SnippetsControllerUpdateSnippetErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Snippet not found
     */
    404: unknown;
    /**
     * Snippet name already exists.
     */
    409: unknown;
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type SnippetsControllerUpdateSnippetError = SnippetsControllerUpdateSnippetErrors[keyof SnippetsControllerUpdateSnippetErrors];

export type SnippetsControllerUpdateSnippetResponses = {
    /**
     * Snippet updated successfully
     */
    200: UpdateSnippetResponseDto;
};

export type SnippetsControllerUpdateSnippetResponse = SnippetsControllerUpdateSnippetResponses[keyof SnippetsControllerUpdateSnippetResponses];

export type SnippetsControllerCreateSnippetData = {
    body: CreateSnippetRequestDto;
    path?: never;
    query?: never;
    url: '/api/snippets';
};

export type SnippetsControllerCreateSnippetErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Snippet name already exists.
     */
    409: unknown;
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type SnippetsControllerCreateSnippetError = SnippetsControllerCreateSnippetErrors[keyof SnippetsControllerCreateSnippetErrors];

export type SnippetsControllerCreateSnippetResponses = {
    /**
     * Snippet created successfully
     */
    201: CreateSnippetResponseDto;
};

export type SnippetsControllerCreateSnippetResponse = SnippetsControllerCreateSnippetResponses[keyof SnippetsControllerCreateSnippetResponses];

export type InternalSquadControllerGetInternalSquadsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/internal-squads';
};

export type InternalSquadControllerGetInternalSquadsErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type InternalSquadControllerGetInternalSquadsError = InternalSquadControllerGetInternalSquadsErrors[keyof InternalSquadControllerGetInternalSquadsErrors];

export type InternalSquadControllerGetInternalSquadsResponses = {
    /**
     * Internal squads retrieved successfully
     */
    200: GetInternalSquadsResponseDto;
};

export type InternalSquadControllerGetInternalSquadsResponse = InternalSquadControllerGetInternalSquadsResponses[keyof InternalSquadControllerGetInternalSquadsResponses];

export type InternalSquadControllerUpdateInternalSquadData = {
    body: UpdateInternalSquadRequestDto;
    path?: never;
    query?: never;
    url: '/api/internal-squads';
};

export type InternalSquadControllerUpdateInternalSquadErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Internal squad not found
     */
    404: unknown;
    /**
     * Internal squad already exists
     */
    409: unknown;
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type InternalSquadControllerUpdateInternalSquadError = InternalSquadControllerUpdateInternalSquadErrors[keyof InternalSquadControllerUpdateInternalSquadErrors];

export type InternalSquadControllerUpdateInternalSquadResponses = {
    /**
     * Internal squad updated successfully
     */
    200: UpdateInternalSquadResponseDto;
};

export type InternalSquadControllerUpdateInternalSquadResponse = InternalSquadControllerUpdateInternalSquadResponses[keyof InternalSquadControllerUpdateInternalSquadResponses];

export type InternalSquadControllerCreateInternalSquadData = {
    body: CreateInternalSquadRequestDto;
    path?: never;
    query?: never;
    url: '/api/internal-squads';
};

export type InternalSquadControllerCreateInternalSquadErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Internal squad already exists
     */
    409: unknown;
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type InternalSquadControllerCreateInternalSquadError = InternalSquadControllerCreateInternalSquadErrors[keyof InternalSquadControllerCreateInternalSquadErrors];

export type InternalSquadControllerCreateInternalSquadResponses = {
    /**
     * Internal squad created successfully
     */
    201: CreateInternalSquadResponseDto;
};

export type InternalSquadControllerCreateInternalSquadResponse = InternalSquadControllerCreateInternalSquadResponses[keyof InternalSquadControllerCreateInternalSquadResponses];

export type InternalSquadControllerDeleteInternalSquadData = {
    body?: never;
    path: {
        uuid: string;
    };
    query?: never;
    url: '/api/internal-squads/{uuid}';
};

export type InternalSquadControllerDeleteInternalSquadErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Internal squad not found
     */
    404: unknown;
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type InternalSquadControllerDeleteInternalSquadError = InternalSquadControllerDeleteInternalSquadErrors[keyof InternalSquadControllerDeleteInternalSquadErrors];

export type InternalSquadControllerDeleteInternalSquadResponses = {
    /**
     * Internal squad deleted successfully
     */
    200: DeleteInternalSquadResponseDto;
};

export type InternalSquadControllerDeleteInternalSquadResponse = InternalSquadControllerDeleteInternalSquadResponses[keyof InternalSquadControllerDeleteInternalSquadResponses];

export type InternalSquadControllerGetInternalSquadByUuidData = {
    body?: never;
    path: {
        uuid: string;
    };
    query?: never;
    url: '/api/internal-squads/{uuid}';
};

export type InternalSquadControllerGetInternalSquadByUuidErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type InternalSquadControllerGetInternalSquadByUuidError = InternalSquadControllerGetInternalSquadByUuidErrors[keyof InternalSquadControllerGetInternalSquadByUuidErrors];

export type InternalSquadControllerGetInternalSquadByUuidResponses = {
    /**
     * Internal squad retrieved successfully
     */
    200: GetInternalSquadByUuidResponseDto;
};

export type InternalSquadControllerGetInternalSquadByUuidResponse = InternalSquadControllerGetInternalSquadByUuidResponses[keyof InternalSquadControllerGetInternalSquadByUuidResponses];

export type InternalSquadControllerGetInternalSquadAccessibleNodesData = {
    body?: never;
    path: {
        /**
         * UUID of the internal squad
         */
        uuid: string;
    };
    query?: never;
    url: '/api/internal-squads/{uuid}/accessible-nodes';
};

export type InternalSquadControllerGetInternalSquadAccessibleNodesErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Internal squad not found
     */
    404: unknown;
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type InternalSquadControllerGetInternalSquadAccessibleNodesError = InternalSquadControllerGetInternalSquadAccessibleNodesErrors[keyof InternalSquadControllerGetInternalSquadAccessibleNodesErrors];

export type InternalSquadControllerGetInternalSquadAccessibleNodesResponses = {
    /**
     * Internal squad accessible nodes fetched successfully
     */
    200: GetInternalSquadAccessibleNodesResponseDto;
};

export type InternalSquadControllerGetInternalSquadAccessibleNodesResponse = InternalSquadControllerGetInternalSquadAccessibleNodesResponses[keyof InternalSquadControllerGetInternalSquadAccessibleNodesResponses];

export type InternalSquadControllerAddUsersToInternalSquadData = {
    body?: never;
    path: {
        uuid: string;
    };
    query?: never;
    url: '/api/internal-squads/{uuid}/bulk-actions/add-users';
};

export type InternalSquadControllerAddUsersToInternalSquadErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Internal squad not found
     */
    404: unknown;
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type InternalSquadControllerAddUsersToInternalSquadError = InternalSquadControllerAddUsersToInternalSquadErrors[keyof InternalSquadControllerAddUsersToInternalSquadErrors];

export type InternalSquadControllerAddUsersToInternalSquadResponses = {
    /**
     * Task added to internal job queue
     */
    200: AddUsersToInternalSquadResponseDto;
};

export type InternalSquadControllerAddUsersToInternalSquadResponse = InternalSquadControllerAddUsersToInternalSquadResponses[keyof InternalSquadControllerAddUsersToInternalSquadResponses];

export type InternalSquadControllerRemoveUsersFromInternalSquadData = {
    body?: never;
    path: {
        uuid: string;
    };
    query?: never;
    url: '/api/internal-squads/{uuid}/bulk-actions/remove-users';
};

export type InternalSquadControllerRemoveUsersFromInternalSquadErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Internal squad not found
     */
    404: unknown;
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type InternalSquadControllerRemoveUsersFromInternalSquadError = InternalSquadControllerRemoveUsersFromInternalSquadErrors[keyof InternalSquadControllerRemoveUsersFromInternalSquadErrors];

export type InternalSquadControllerRemoveUsersFromInternalSquadResponses = {
    /**
     * Task added to internal job queue
     */
    200: RemoveUsersFromInternalSquadResponseDto;
};

export type InternalSquadControllerRemoveUsersFromInternalSquadResponse = InternalSquadControllerRemoveUsersFromInternalSquadResponses[keyof InternalSquadControllerRemoveUsersFromInternalSquadResponses];

export type InternalSquadControllerReorderInternalSquadsData = {
    body: ReorderInternalSquadsRequestDto;
    path?: never;
    query?: never;
    url: '/api/internal-squads/actions/reorder';
};

export type InternalSquadControllerReorderInternalSquadsErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type InternalSquadControllerReorderInternalSquadsError = InternalSquadControllerReorderInternalSquadsErrors[keyof InternalSquadControllerReorderInternalSquadsErrors];

export type InternalSquadControllerReorderInternalSquadsResponses = {
    /**
     * Internal squads reordered successfully
     */
    200: ReorderInternalSquadsResponseDto;
};

export type InternalSquadControllerReorderInternalSquadsResponse = InternalSquadControllerReorderInternalSquadsResponses[keyof InternalSquadControllerReorderInternalSquadsResponses];

export type ExternalSquadControllerGetExternalSquadsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/external-squads';
};

export type ExternalSquadControllerGetExternalSquadsErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type ExternalSquadControllerGetExternalSquadsError = ExternalSquadControllerGetExternalSquadsErrors[keyof ExternalSquadControllerGetExternalSquadsErrors];

export type ExternalSquadControllerGetExternalSquadsResponses = {
    /**
     * External squads retrieved successfully
     */
    200: GetExternalSquadsResponseDto;
};

export type ExternalSquadControllerGetExternalSquadsResponse = ExternalSquadControllerGetExternalSquadsResponses[keyof ExternalSquadControllerGetExternalSquadsResponses];

export type ExternalSquadControllerUpdateExternalSquadData = {
    body: UpdateExternalSquadRequestDto;
    path?: never;
    query?: never;
    url: '/api/external-squads';
};

export type ExternalSquadControllerUpdateExternalSquadErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * External squad not found
     */
    404: unknown;
    /**
     * External squad already exists
     */
    409: unknown;
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type ExternalSquadControllerUpdateExternalSquadError = ExternalSquadControllerUpdateExternalSquadErrors[keyof ExternalSquadControllerUpdateExternalSquadErrors];

export type ExternalSquadControllerUpdateExternalSquadResponses = {
    /**
     * External squad updated successfully
     */
    200: UpdateExternalSquadResponseDto;
};

export type ExternalSquadControllerUpdateExternalSquadResponse = ExternalSquadControllerUpdateExternalSquadResponses[keyof ExternalSquadControllerUpdateExternalSquadResponses];

export type ExternalSquadControllerCreateExternalSquadData = {
    body: CreateExternalSquadRequestDto;
    path?: never;
    query?: never;
    url: '/api/external-squads';
};

export type ExternalSquadControllerCreateExternalSquadErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * External squad already exists
     */
    409: unknown;
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type ExternalSquadControllerCreateExternalSquadError = ExternalSquadControllerCreateExternalSquadErrors[keyof ExternalSquadControllerCreateExternalSquadErrors];

export type ExternalSquadControllerCreateExternalSquadResponses = {
    /**
     * External squad created successfully
     */
    201: CreateExternalSquadResponseDto;
};

export type ExternalSquadControllerCreateExternalSquadResponse = ExternalSquadControllerCreateExternalSquadResponses[keyof ExternalSquadControllerCreateExternalSquadResponses];

export type ExternalSquadControllerDeleteExternalSquadData = {
    body?: never;
    path: {
        uuid: string;
    };
    query?: never;
    url: '/api/external-squads/{uuid}';
};

export type ExternalSquadControllerDeleteExternalSquadErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * External squad not found
     */
    404: unknown;
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type ExternalSquadControllerDeleteExternalSquadError = ExternalSquadControllerDeleteExternalSquadErrors[keyof ExternalSquadControllerDeleteExternalSquadErrors];

export type ExternalSquadControllerDeleteExternalSquadResponses = {
    /**
     * External squad deleted successfully
     */
    200: DeleteExternalSquadResponseDto;
};

export type ExternalSquadControllerDeleteExternalSquadResponse = ExternalSquadControllerDeleteExternalSquadResponses[keyof ExternalSquadControllerDeleteExternalSquadResponses];

export type ExternalSquadControllerGetExternalSquadByUuidData = {
    body?: never;
    path: {
        uuid: string;
    };
    query?: never;
    url: '/api/external-squads/{uuid}';
};

export type ExternalSquadControllerGetExternalSquadByUuidErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type ExternalSquadControllerGetExternalSquadByUuidError = ExternalSquadControllerGetExternalSquadByUuidErrors[keyof ExternalSquadControllerGetExternalSquadByUuidErrors];

export type ExternalSquadControllerGetExternalSquadByUuidResponses = {
    /**
     * External squad retrieved successfully
     */
    200: GetExternalSquadByUuidResponseDto;
};

export type ExternalSquadControllerGetExternalSquadByUuidResponse = ExternalSquadControllerGetExternalSquadByUuidResponses[keyof ExternalSquadControllerGetExternalSquadByUuidResponses];

export type ExternalSquadControllerAddUsersToExternalSquadData = {
    body?: never;
    path: {
        uuid: string;
    };
    query?: never;
    url: '/api/external-squads/{uuid}/bulk-actions/add-users';
};

export type ExternalSquadControllerAddUsersToExternalSquadErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * External squad not found
     */
    404: unknown;
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type ExternalSquadControllerAddUsersToExternalSquadError = ExternalSquadControllerAddUsersToExternalSquadErrors[keyof ExternalSquadControllerAddUsersToExternalSquadErrors];

export type ExternalSquadControllerAddUsersToExternalSquadResponses = {
    /**
     * Task added to external job queue
     */
    200: AddUsersToExternalSquadResponseDto;
};

export type ExternalSquadControllerAddUsersToExternalSquadResponse = ExternalSquadControllerAddUsersToExternalSquadResponses[keyof ExternalSquadControllerAddUsersToExternalSquadResponses];

export type ExternalSquadControllerRemoveUsersFromExternalSquadData = {
    body?: never;
    path: {
        uuid: string;
    };
    query?: never;
    url: '/api/external-squads/{uuid}/bulk-actions/remove-users';
};

export type ExternalSquadControllerRemoveUsersFromExternalSquadErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * External squad not found
     */
    404: unknown;
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type ExternalSquadControllerRemoveUsersFromExternalSquadError = ExternalSquadControllerRemoveUsersFromExternalSquadErrors[keyof ExternalSquadControllerRemoveUsersFromExternalSquadErrors];

export type ExternalSquadControllerRemoveUsersFromExternalSquadResponses = {
    /**
     * Task added to external job queue
     */
    200: RemoveUsersFromExternalSquadResponseDto;
};

export type ExternalSquadControllerRemoveUsersFromExternalSquadResponse = ExternalSquadControllerRemoveUsersFromExternalSquadResponses[keyof ExternalSquadControllerRemoveUsersFromExternalSquadResponses];

export type ExternalSquadControllerReorderExternalSquadsData = {
    body: ReorderExternalSquadsRequestDto;
    path?: never;
    query?: never;
    url: '/api/external-squads/actions/reorder';
};

export type ExternalSquadControllerReorderExternalSquadsErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type ExternalSquadControllerReorderExternalSquadsError = ExternalSquadControllerReorderExternalSquadsErrors[keyof ExternalSquadControllerReorderExternalSquadsErrors];

export type ExternalSquadControllerReorderExternalSquadsResponses = {
    /**
     * External squads reordered successfully
     */
    200: ReorderExternalSquadsResponseDto;
};

export type ExternalSquadControllerReorderExternalSquadsResponse = ExternalSquadControllerReorderExternalSquadsResponses[keyof ExternalSquadControllerReorderExternalSquadsResponses];

export type KeygenControllerGenerateKeyData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/keygen';
};

export type KeygenControllerGenerateKeyErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type KeygenControllerGenerateKeyError = KeygenControllerGenerateKeyErrors[keyof KeygenControllerGenerateKeyErrors];

export type KeygenControllerGenerateKeyResponses = {
    /**
     * Get SSL_CERT for Remnawave Node
     */
    200: GetPubKeyResponseDto;
};

export type KeygenControllerGenerateKeyResponse = KeygenControllerGenerateKeyResponses[keyof KeygenControllerGenerateKeyResponses];

export type NodesControllerGetAllNodesTagsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/nodes/tags';
};

export type NodesControllerGetAllNodesTagsErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type NodesControllerGetAllNodesTagsError = NodesControllerGetAllNodesTagsErrors[keyof NodesControllerGetAllNodesTagsErrors];

export type NodesControllerGetAllNodesTagsResponses = {
    /**
     * Nodes tags fetched
     */
    200: GetAllNodesTagsResponseDto;
};

export type NodesControllerGetAllNodesTagsResponse = NodesControllerGetAllNodesTagsResponses[keyof NodesControllerGetAllNodesTagsResponses];

export type NodesControllerGetAllNodesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/nodes';
};

export type NodesControllerGetAllNodesErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type NodesControllerGetAllNodesError = NodesControllerGetAllNodesErrors[keyof NodesControllerGetAllNodesErrors];

export type NodesControllerGetAllNodesResponses = {
    /**
     * Nodes fetched
     */
    200: GetAllNodesResponseDto;
};

export type NodesControllerGetAllNodesResponse = NodesControllerGetAllNodesResponses[keyof NodesControllerGetAllNodesResponses];

export type NodesControllerUpdateNodeData = {
    body: UpdateNodeRequestDto;
    path?: never;
    query?: never;
    url: '/api/nodes';
};

export type NodesControllerUpdateNodeErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type NodesControllerUpdateNodeError = NodesControllerUpdateNodeErrors[keyof NodesControllerUpdateNodeErrors];

export type NodesControllerUpdateNodeResponses = {
    /**
     * Node updated
     */
    200: UpdateNodeResponseDto;
};

export type NodesControllerUpdateNodeResponse = NodesControllerUpdateNodeResponses[keyof NodesControllerUpdateNodeResponses];

export type NodesControllerCreateNodeData = {
    body: CreateNodeRequestDto;
    path?: never;
    query?: never;
    url: '/api/nodes';
};

export type NodesControllerCreateNodeErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type NodesControllerCreateNodeError = NodesControllerCreateNodeErrors[keyof NodesControllerCreateNodeErrors];

export type NodesControllerCreateNodeResponses = {
    /**
     * Node created successfully
     */
    201: CreateNodeResponseDto;
};

export type NodesControllerCreateNodeResponse = NodesControllerCreateNodeResponses[keyof NodesControllerCreateNodeResponses];

export type NodesControllerDeleteNodeData = {
    body?: never;
    path: {
        /**
         * Node UUID
         */
        uuid: string;
    };
    query?: never;
    url: '/api/nodes/{uuid}';
};

export type NodesControllerDeleteNodeErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type NodesControllerDeleteNodeError = NodesControllerDeleteNodeErrors[keyof NodesControllerDeleteNodeErrors];

export type NodesControllerDeleteNodeResponses = {
    /**
     * Node deleted
     */
    200: DeleteNodeResponseDto;
};

export type NodesControllerDeleteNodeResponse = NodesControllerDeleteNodeResponses[keyof NodesControllerDeleteNodeResponses];

export type NodesControllerGetOneNodeData = {
    body?: never;
    path: {
        /**
         * Node UUID
         */
        uuid: string;
    };
    query?: never;
    url: '/api/nodes/{uuid}';
};

export type NodesControllerGetOneNodeErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type NodesControllerGetOneNodeError = NodesControllerGetOneNodeErrors[keyof NodesControllerGetOneNodeErrors];

export type NodesControllerGetOneNodeResponses = {
    /**
     * Node fetched
     */
    200: GetOneNodeResponseDto;
};

export type NodesControllerGetOneNodeResponse = NodesControllerGetOneNodeResponses[keyof NodesControllerGetOneNodeResponses];

export type NodesControllerEnableNodeData = {
    body?: never;
    path: {
        /**
         * Node UUID
         */
        uuid: string;
    };
    query?: never;
    url: '/api/nodes/{uuid}/actions/enable';
};

export type NodesControllerEnableNodeErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type NodesControllerEnableNodeError = NodesControllerEnableNodeErrors[keyof NodesControllerEnableNodeErrors];

export type NodesControllerEnableNodeResponses = {
    /**
     * Node enabled
     */
    200: EnableNodeResponseDto;
};

export type NodesControllerEnableNodeResponse = NodesControllerEnableNodeResponses[keyof NodesControllerEnableNodeResponses];

export type NodesControllerDisableNodeData = {
    body?: never;
    path: {
        /**
         * Node UUID
         */
        uuid: string;
    };
    query?: never;
    url: '/api/nodes/{uuid}/actions/disable';
};

export type NodesControllerDisableNodeErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type NodesControllerDisableNodeError = NodesControllerDisableNodeErrors[keyof NodesControllerDisableNodeErrors];

export type NodesControllerDisableNodeResponses = {
    /**
     * Node disabled
     */
    200: DisableNodeResponseDto;
};

export type NodesControllerDisableNodeResponse = NodesControllerDisableNodeResponses[keyof NodesControllerDisableNodeResponses];

export type NodesControllerRestartNodeData = {
    body?: never;
    path: {
        /**
         * Node UUID
         */
        uuid: string;
    };
    query?: never;
    url: '/api/nodes/{uuid}/actions/restart';
};

export type NodesControllerRestartNodeErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type NodesControllerRestartNodeError = NodesControllerRestartNodeErrors[keyof NodesControllerRestartNodeErrors];

export type NodesControllerRestartNodeResponses = {
    /**
     * Node restarted
     */
    200: RestartNodeResponseDto;
};

export type NodesControllerRestartNodeResponse = NodesControllerRestartNodeResponses[keyof NodesControllerRestartNodeResponses];

export type NodesControllerResetNodeTrafficData = {
    body?: never;
    path: {
        /**
         * Node UUID
         */
        uuid: string;
    };
    query?: never;
    url: '/api/nodes/{uuid}/actions/reset-traffic';
};

export type NodesControllerResetNodeTrafficErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type NodesControllerResetNodeTrafficError = NodesControllerResetNodeTrafficErrors[keyof NodesControllerResetNodeTrafficErrors];

export type NodesControllerResetNodeTrafficResponses = {
    /**
     * Event sent
     */
    200: ResetNodeTrafficResponseDto;
};

export type NodesControllerResetNodeTrafficResponse = NodesControllerResetNodeTrafficResponses[keyof NodesControllerResetNodeTrafficResponses];

export type NodesControllerRestartAllNodesData = {
    body: RestartAllNodesRequestBodyDto;
    path?: never;
    query?: never;
    url: '/api/nodes/actions/restart-all';
};

export type NodesControllerRestartAllNodesErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type NodesControllerRestartAllNodesError = NodesControllerRestartAllNodesErrors[keyof NodesControllerRestartAllNodesErrors];

export type NodesControllerRestartAllNodesResponses = {
    /**
     * All nodes restarted
     */
    200: RestartAllNodesResponseDto;
};

export type NodesControllerRestartAllNodesResponse = NodesControllerRestartAllNodesResponses[keyof NodesControllerRestartAllNodesResponses];

export type NodesControllerReorderNodesData = {
    body: ReorderNodeRequestDto;
    path?: never;
    query?: never;
    url: '/api/nodes/actions/reorder';
};

export type NodesControllerReorderNodesErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type NodesControllerReorderNodesError = NodesControllerReorderNodesErrors[keyof NodesControllerReorderNodesErrors];

export type NodesControllerReorderNodesResponses = {
    /**
     * Nodes reordered successfully
     */
    200: ReorderNodeResponseDto;
};

export type NodesControllerReorderNodesResponse = NodesControllerReorderNodesResponses[keyof NodesControllerReorderNodesResponses];

export type NodesControllerProfileModificationData = {
    body: ProfileModificationRequestDto;
    path?: never;
    query?: never;
    url: '/api/nodes/bulk-actions/profile-modification';
};

export type NodesControllerProfileModificationErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type NodesControllerProfileModificationError = NodesControllerProfileModificationErrors[keyof NodesControllerProfileModificationErrors];

export type NodesControllerProfileModificationResponses = {
    /**
     * Event sent successfully
     */
    200: ProfileModificationResponseDto;
};

export type NodesControllerProfileModificationResponse = NodesControllerProfileModificationResponses[keyof NodesControllerProfileModificationResponses];

export type HostsControllerGetAllHostTagsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/hosts/tags';
};

export type HostsControllerGetAllHostTagsErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type HostsControllerGetAllHostTagsError = HostsControllerGetAllHostTagsErrors[keyof HostsControllerGetAllHostTagsErrors];

export type HostsControllerGetAllHostTagsResponses = {
    /**
     * Host tags fetched successfully
     */
    200: GetAllHostTagsResponseDto;
};

export type HostsControllerGetAllHostTagsResponse = HostsControllerGetAllHostTagsResponses[keyof HostsControllerGetAllHostTagsResponses];

export type HostsControllerGetAllHostsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/hosts';
};

export type HostsControllerGetAllHostsErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type HostsControllerGetAllHostsError = HostsControllerGetAllHostsErrors[keyof HostsControllerGetAllHostsErrors];

export type HostsControllerGetAllHostsResponses = {
    /**
     * Hosts fetched successfully
     */
    200: GetAllHostsResponseDto;
};

export type HostsControllerGetAllHostsResponse = HostsControllerGetAllHostsResponses[keyof HostsControllerGetAllHostsResponses];

export type HostsControllerUpdateHostData = {
    body: UpdateHostRequestDto;
    path?: never;
    query?: never;
    url: '/api/hosts';
};

export type HostsControllerUpdateHostErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type HostsControllerUpdateHostError = HostsControllerUpdateHostErrors[keyof HostsControllerUpdateHostErrors];

export type HostsControllerUpdateHostResponses = {
    /**
     * Host updated successfully
     */
    200: UpdateHostResponseDto;
};

export type HostsControllerUpdateHostResponse = HostsControllerUpdateHostResponses[keyof HostsControllerUpdateHostResponses];

export type HostsControllerCreateHostData = {
    body: CreateHostRequestDto;
    path?: never;
    query?: never;
    url: '/api/hosts';
};

export type HostsControllerCreateHostErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type HostsControllerCreateHostError = HostsControllerCreateHostErrors[keyof HostsControllerCreateHostErrors];

export type HostsControllerCreateHostResponses = {
    /**
     * Host created successfully
     */
    201: CreateHostResponseDto;
};

export type HostsControllerCreateHostResponse = HostsControllerCreateHostResponses[keyof HostsControllerCreateHostResponses];

export type HostsControllerDeleteHostData = {
    body?: never;
    path: {
        /**
         * UUID of the host
         */
        uuid: string;
    };
    query?: never;
    url: '/api/hosts/{uuid}';
};

export type HostsControllerDeleteHostErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Host not found
     */
    404: unknown;
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type HostsControllerDeleteHostError = HostsControllerDeleteHostErrors[keyof HostsControllerDeleteHostErrors];

export type HostsControllerDeleteHostResponses = {
    /**
     * Host deleted successfully
     */
    200: DeleteHostResponseDto;
};

export type HostsControllerDeleteHostResponse = HostsControllerDeleteHostResponses[keyof HostsControllerDeleteHostResponses];

export type HostsControllerGetOneHostData = {
    body?: never;
    path: {
        /**
         * UUID of the host
         */
        uuid: string;
    };
    query?: never;
    url: '/api/hosts/{uuid}';
};

export type HostsControllerGetOneHostErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type HostsControllerGetOneHostError = HostsControllerGetOneHostErrors[keyof HostsControllerGetOneHostErrors];

export type HostsControllerGetOneHostResponses = {
    /**
     * Host fetched successfully
     */
    200: GetOneHostResponseDto;
};

export type HostsControllerGetOneHostResponse = HostsControllerGetOneHostResponses[keyof HostsControllerGetOneHostResponses];

export type HostsControllerReorderHostsData = {
    body: ReorderHostRequestDto;
    path?: never;
    query?: never;
    url: '/api/hosts/actions/reorder';
};

export type HostsControllerReorderHostsErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type HostsControllerReorderHostsError = HostsControllerReorderHostsErrors[keyof HostsControllerReorderHostsErrors];

export type HostsControllerReorderHostsResponses = {
    /**
     * Hosts reordered successfully
     */
    200: ReorderHostResponseDto;
};

export type HostsControllerReorderHostsResponse = HostsControllerReorderHostsResponses[keyof HostsControllerReorderHostsResponses];

export type HostsBulkActionsControllerDeleteHostsData = {
    body: BulkDeleteHostsRequestDto;
    path?: never;
    query?: never;
    url: '/api/hosts/bulk/delete';
};

export type HostsBulkActionsControllerDeleteHostsErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type HostsBulkActionsControllerDeleteHostsError = HostsBulkActionsControllerDeleteHostsErrors[keyof HostsBulkActionsControllerDeleteHostsErrors];

export type HostsBulkActionsControllerDeleteHostsResponses = {
    /**
     * Hosts deleted successfully
     */
    200: BulkDeleteHostsResponseDto;
};

export type HostsBulkActionsControllerDeleteHostsResponse = HostsBulkActionsControllerDeleteHostsResponses[keyof HostsBulkActionsControllerDeleteHostsResponses];

export type HostsBulkActionsControllerDisableHostsData = {
    body: BulkDisableHostsRequestDto;
    path?: never;
    query?: never;
    url: '/api/hosts/bulk/disable';
};

export type HostsBulkActionsControllerDisableHostsErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type HostsBulkActionsControllerDisableHostsError = HostsBulkActionsControllerDisableHostsErrors[keyof HostsBulkActionsControllerDisableHostsErrors];

export type HostsBulkActionsControllerDisableHostsResponses = {
    /**
     * Hosts disabled successfully
     */
    200: BulkDisableHostsResponseDto;
};

export type HostsBulkActionsControllerDisableHostsResponse = HostsBulkActionsControllerDisableHostsResponses[keyof HostsBulkActionsControllerDisableHostsResponses];

export type HostsBulkActionsControllerEnableHostsData = {
    body: BulkEnableHostsRequestDto;
    path?: never;
    query?: never;
    url: '/api/hosts/bulk/enable';
};

export type HostsBulkActionsControllerEnableHostsErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type HostsBulkActionsControllerEnableHostsError = HostsBulkActionsControllerEnableHostsErrors[keyof HostsBulkActionsControllerEnableHostsErrors];

export type HostsBulkActionsControllerEnableHostsResponses = {
    /**
     * Hosts enabled successfully
     */
    200: BulkEnableHostsResponseDto;
};

export type HostsBulkActionsControllerEnableHostsResponse = HostsBulkActionsControllerEnableHostsResponses[keyof HostsBulkActionsControllerEnableHostsResponses];

export type HostsBulkActionsControllerSetInboundToHostsData = {
    body: SetInboundToManyHostsRequestDto;
    path?: never;
    query?: never;
    url: '/api/hosts/bulk/set-inbound';
};

export type HostsBulkActionsControllerSetInboundToHostsErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type HostsBulkActionsControllerSetInboundToHostsError = HostsBulkActionsControllerSetInboundToHostsErrors[keyof HostsBulkActionsControllerSetInboundToHostsErrors];

export type HostsBulkActionsControllerSetInboundToHostsResponses = {
    /**
     * Hosts inbound set successfully
     */
    200: SetInboundToManyHostsResponseDto;
};

export type HostsBulkActionsControllerSetInboundToHostsResponse = HostsBulkActionsControllerSetInboundToHostsResponses[keyof HostsBulkActionsControllerSetInboundToHostsResponses];

export type HostsBulkActionsControllerSetPortToHostsData = {
    body: SetPortToManyHostsRequestDto;
    path?: never;
    query?: never;
    url: '/api/hosts/bulk/set-port';
};

export type HostsBulkActionsControllerSetPortToHostsErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type HostsBulkActionsControllerSetPortToHostsError = HostsBulkActionsControllerSetPortToHostsErrors[keyof HostsBulkActionsControllerSetPortToHostsErrors];

export type HostsBulkActionsControllerSetPortToHostsResponses = {
    /**
     * Hosts port set successfully
     */
    200: SetPortToManyHostsResponseDto;
};

export type HostsBulkActionsControllerSetPortToHostsResponse = HostsBulkActionsControllerSetPortToHostsResponses[keyof HostsBulkActionsControllerSetPortToHostsResponses];

export type NodesUserUsageHistoryControllerGetNodeUserUsageData = {
    body?: never;
    path: {
        /**
         * UUID of the node
         */
        uuid: string;
    };
    query: {
        /**
         * Start date
         */
        start: string;
        /**
         * End date
         */
        end: string;
    };
    url: '/api/nodes/usage/{uuid}/users/range';
};

export type NodesUserUsageHistoryControllerGetNodeUserUsageErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type NodesUserUsageHistoryControllerGetNodeUserUsageError = NodesUserUsageHistoryControllerGetNodeUserUsageErrors[keyof NodesUserUsageHistoryControllerGetNodeUserUsageErrors];

export type NodesUserUsageHistoryControllerGetNodeUserUsageResponses = {
    /**
     * Nodes user usage by range fetched successfully
     */
    200: GetNodeUserUsageByRangeResponseDto;
};

export type NodesUserUsageHistoryControllerGetNodeUserUsageResponse = NodesUserUsageHistoryControllerGetNodeUserUsageResponses[keyof NodesUserUsageHistoryControllerGetNodeUserUsageResponses];

export type NodesUserUsageHistoryControllerGetNodesRealtimeUsageData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/nodes/usage/realtime';
};

export type NodesUserUsageHistoryControllerGetNodesRealtimeUsageErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type NodesUserUsageHistoryControllerGetNodesRealtimeUsageError = NodesUserUsageHistoryControllerGetNodesRealtimeUsageErrors[keyof NodesUserUsageHistoryControllerGetNodesRealtimeUsageErrors];

export type NodesUserUsageHistoryControllerGetNodesRealtimeUsageResponses = {
    /**
     * Nodes realtime usage fetched successfully
     */
    200: GetNodesRealtimeUsageResponseDto;
};

export type NodesUserUsageHistoryControllerGetNodesRealtimeUsageResponse = NodesUserUsageHistoryControllerGetNodesRealtimeUsageResponses[keyof NodesUserUsageHistoryControllerGetNodesRealtimeUsageResponses];

export type HwidUserDevicesControllerGetAllUsersData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Page size for pagination
         */
        size?: number;
        /**
         * Offset for pagination
         */
        start?: number;
    };
    url: '/api/hwid/devices';
};

export type HwidUserDevicesControllerGetAllUsersErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type HwidUserDevicesControllerGetAllUsersError = HwidUserDevicesControllerGetAllUsersErrors[keyof HwidUserDevicesControllerGetAllUsersErrors];

export type HwidUserDevicesControllerGetAllUsersResponses = {
    /**
     * Hwid devices fetched successfully
     */
    200: GetAllHwidDevicesResponseDto;
};

export type HwidUserDevicesControllerGetAllUsersResponse = HwidUserDevicesControllerGetAllUsersResponses[keyof HwidUserDevicesControllerGetAllUsersResponses];

export type HwidUserDevicesControllerCreateUserHwidDeviceData = {
    body: CreateUserHwidDeviceRequestDto;
    path?: never;
    query?: never;
    url: '/api/hwid/devices';
};

export type HwidUserDevicesControllerCreateUserHwidDeviceErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * One of requested resources not found
     */
    404: unknown;
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type HwidUserDevicesControllerCreateUserHwidDeviceError = HwidUserDevicesControllerCreateUserHwidDeviceErrors[keyof HwidUserDevicesControllerCreateUserHwidDeviceErrors];

export type HwidUserDevicesControllerCreateUserHwidDeviceResponses = {
    /**
     * User HWID device created successfully
     */
    200: CreateUserHwidDeviceResponseDto;
};

export type HwidUserDevicesControllerCreateUserHwidDeviceResponse = HwidUserDevicesControllerCreateUserHwidDeviceResponses[keyof HwidUserDevicesControllerCreateUserHwidDeviceResponses];

export type HwidUserDevicesControllerDeleteUserHwidDeviceData = {
    body: DeleteUserHwidDeviceRequestDto;
    path?: never;
    query?: never;
    url: '/api/hwid/devices/delete';
};

export type HwidUserDevicesControllerDeleteUserHwidDeviceErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * One of requested resources not found
     */
    404: unknown;
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type HwidUserDevicesControllerDeleteUserHwidDeviceError = HwidUserDevicesControllerDeleteUserHwidDeviceErrors[keyof HwidUserDevicesControllerDeleteUserHwidDeviceErrors];

export type HwidUserDevicesControllerDeleteUserHwidDeviceResponses = {
    /**
     * User HWID device deleted successfully
     */
    200: DeleteUserHwidDeviceResponseDto;
};

export type HwidUserDevicesControllerDeleteUserHwidDeviceResponse = HwidUserDevicesControllerDeleteUserHwidDeviceResponses[keyof HwidUserDevicesControllerDeleteUserHwidDeviceResponses];

export type HwidUserDevicesControllerDeleteAllUserHwidDevicesData = {
    body: DeleteAllUserHwidDevicesRequestDto;
    path?: never;
    query?: never;
    url: '/api/hwid/devices/delete-all';
};

export type HwidUserDevicesControllerDeleteAllUserHwidDevicesErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * One of requested resources not found
     */
    404: unknown;
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type HwidUserDevicesControllerDeleteAllUserHwidDevicesError = HwidUserDevicesControllerDeleteAllUserHwidDevicesErrors[keyof HwidUserDevicesControllerDeleteAllUserHwidDevicesErrors];

export type HwidUserDevicesControllerDeleteAllUserHwidDevicesResponses = {
    /**
     * User HWID devices deleted successfully
     */
    200: DeleteAllUserHwidDevicesResponseDto;
};

export type HwidUserDevicesControllerDeleteAllUserHwidDevicesResponse = HwidUserDevicesControllerDeleteAllUserHwidDevicesResponses[keyof HwidUserDevicesControllerDeleteAllUserHwidDevicesResponses];

export type HwidUserDevicesControllerGetHwidDevicesStatsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/hwid/devices/stats';
};

export type HwidUserDevicesControllerGetHwidDevicesStatsErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type HwidUserDevicesControllerGetHwidDevicesStatsError = HwidUserDevicesControllerGetHwidDevicesStatsErrors[keyof HwidUserDevicesControllerGetHwidDevicesStatsErrors];

export type HwidUserDevicesControllerGetHwidDevicesStatsResponses = {
    /**
     * Hwid devices stats fetched successfully
     */
    200: GetHwidDevicesStatsResponseDto;
};

export type HwidUserDevicesControllerGetHwidDevicesStatsResponse = HwidUserDevicesControllerGetHwidDevicesStatsResponses[keyof HwidUserDevicesControllerGetHwidDevicesStatsResponses];

export type HwidUserDevicesControllerGetTopUsersByHwidDevicesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Page size for pagination
         */
        size?: number;
        /**
         * Offset for pagination
         */
        start?: number;
    };
    url: '/api/hwid/devices/top-users';
};

export type HwidUserDevicesControllerGetTopUsersByHwidDevicesErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type HwidUserDevicesControllerGetTopUsersByHwidDevicesError = HwidUserDevicesControllerGetTopUsersByHwidDevicesErrors[keyof HwidUserDevicesControllerGetTopUsersByHwidDevicesErrors];

export type HwidUserDevicesControllerGetTopUsersByHwidDevicesResponses = {
    /**
     * Top users by HWID devices fetched successfully
     */
    200: GetTopUsersByHwidDevicesResponseDto;
};

export type HwidUserDevicesControllerGetTopUsersByHwidDevicesResponse = HwidUserDevicesControllerGetTopUsersByHwidDevicesResponses[keyof HwidUserDevicesControllerGetTopUsersByHwidDevicesResponses];

export type HwidUserDevicesControllerGetUserHwidDevicesData = {
    body?: never;
    path: {
        /**
         * UUID of the user
         */
        userUuid: string;
    };
    query?: never;
    url: '/api/hwid/devices/{userUuid}';
};

export type HwidUserDevicesControllerGetUserHwidDevicesErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * One of requested resources not found
     */
    404: unknown;
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type HwidUserDevicesControllerGetUserHwidDevicesError = HwidUserDevicesControllerGetUserHwidDevicesErrors[keyof HwidUserDevicesControllerGetUserHwidDevicesErrors];

export type HwidUserDevicesControllerGetUserHwidDevicesResponses = {
    /**
     * User HWID devices fetched successfully
     */
    200: GetUserHwidDevicesResponseDto;
};

export type HwidUserDevicesControllerGetUserHwidDevicesResponse = HwidUserDevicesControllerGetUserHwidDevicesResponses[keyof HwidUserDevicesControllerGetUserHwidDevicesResponses];

export type NodesUsageHistoryControllerGetNodesUsageByRangeData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Start date
         */
        start: string;
        /**
         * End date
         */
        end: string;
    };
    url: '/api/nodes/usage/range';
};

export type NodesUsageHistoryControllerGetNodesUsageByRangeErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type NodesUsageHistoryControllerGetNodesUsageByRangeError = NodesUsageHistoryControllerGetNodesUsageByRangeErrors[keyof NodesUsageHistoryControllerGetNodesUsageByRangeErrors];

export type NodesUsageHistoryControllerGetNodesUsageByRangeResponses = {
    /**
     * Nodes usage by range fetched successfully
     */
    200: GetNodesUsageByRangeResponseDto;
};

export type NodesUsageHistoryControllerGetNodesUsageByRangeResponse = NodesUsageHistoryControllerGetNodesUsageByRangeResponses[keyof NodesUsageHistoryControllerGetNodesUsageByRangeResponses];

export type InfraBillingControllerGetInfraProvidersData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/infra-billing/providers';
};

export type InfraBillingControllerGetInfraProvidersErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type InfraBillingControllerGetInfraProvidersError = InfraBillingControllerGetInfraProvidersErrors[keyof InfraBillingControllerGetInfraProvidersErrors];

export type InfraBillingControllerGetInfraProvidersResponses = {
    /**
     * Infra providers retrieved successfully
     */
    200: GetInfraProvidersResponseDto;
};

export type InfraBillingControllerGetInfraProvidersResponse = InfraBillingControllerGetInfraProvidersResponses[keyof InfraBillingControllerGetInfraProvidersResponses];

export type InfraBillingControllerUpdateInfraProviderData = {
    body: UpdateInfraProviderRequestDto;
    path?: never;
    query?: never;
    url: '/api/infra-billing/providers';
};

export type InfraBillingControllerUpdateInfraProviderErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type InfraBillingControllerUpdateInfraProviderError = InfraBillingControllerUpdateInfraProviderErrors[keyof InfraBillingControllerUpdateInfraProviderErrors];

export type InfraBillingControllerUpdateInfraProviderResponses = {
    /**
     * Infra provider updated successfully
     */
    200: UpdateInfraProviderResponseDto;
};

export type InfraBillingControllerUpdateInfraProviderResponse = InfraBillingControllerUpdateInfraProviderResponses[keyof InfraBillingControllerUpdateInfraProviderResponses];

export type InfraBillingControllerCreateInfraProviderData = {
    body: CreateInfraProviderRequestDto;
    path?: never;
    query?: never;
    url: '/api/infra-billing/providers';
};

export type InfraBillingControllerCreateInfraProviderErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type InfraBillingControllerCreateInfraProviderError = InfraBillingControllerCreateInfraProviderErrors[keyof InfraBillingControllerCreateInfraProviderErrors];

export type InfraBillingControllerCreateInfraProviderResponses = {
    /**
     * Infra provider created successfully
     */
    201: CreateInfraProviderResponseDto;
};

export type InfraBillingControllerCreateInfraProviderResponse = InfraBillingControllerCreateInfraProviderResponses[keyof InfraBillingControllerCreateInfraProviderResponses];

export type InfraBillingControllerDeleteInfraProviderByUuidData = {
    body?: never;
    path: {
        uuid: string;
    };
    query?: never;
    url: '/api/infra-billing/providers/{uuid}';
};

export type InfraBillingControllerDeleteInfraProviderByUuidErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type InfraBillingControllerDeleteInfraProviderByUuidError = InfraBillingControllerDeleteInfraProviderByUuidErrors[keyof InfraBillingControllerDeleteInfraProviderByUuidErrors];

export type InfraBillingControllerDeleteInfraProviderByUuidResponses = {
    /**
     * Infra provider deleted successfully
     */
    200: DeleteInfraProviderByUuidResponseDto;
};

export type InfraBillingControllerDeleteInfraProviderByUuidResponse = InfraBillingControllerDeleteInfraProviderByUuidResponses[keyof InfraBillingControllerDeleteInfraProviderByUuidResponses];

export type InfraBillingControllerGetInfraProviderByUuidData = {
    body?: never;
    path: {
        uuid: string;
    };
    query?: never;
    url: '/api/infra-billing/providers/{uuid}';
};

export type InfraBillingControllerGetInfraProviderByUuidErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Infra provider not found
     */
    404: unknown;
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type InfraBillingControllerGetInfraProviderByUuidError = InfraBillingControllerGetInfraProviderByUuidErrors[keyof InfraBillingControllerGetInfraProviderByUuidErrors];

export type InfraBillingControllerGetInfraProviderByUuidResponses = {
    /**
     * Infra provider retrieved successfully
     */
    200: GetInfraProviderByUuidResponseDto;
};

export type InfraBillingControllerGetInfraProviderByUuidResponse = InfraBillingControllerGetInfraProviderByUuidResponses[keyof InfraBillingControllerGetInfraProviderByUuidResponses];

export type InfraBillingControllerGetInfraBillingHistoryRecordsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/infra-billing/history';
};

export type InfraBillingControllerGetInfraBillingHistoryRecordsErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type InfraBillingControllerGetInfraBillingHistoryRecordsError = InfraBillingControllerGetInfraBillingHistoryRecordsErrors[keyof InfraBillingControllerGetInfraBillingHistoryRecordsErrors];

export type InfraBillingControllerGetInfraBillingHistoryRecordsResponses = {
    /**
     * Infra billing history records retrieved successfully
     */
    200: GetInfraBillingHistoryRecordsResponseDto;
};

export type InfraBillingControllerGetInfraBillingHistoryRecordsResponse = InfraBillingControllerGetInfraBillingHistoryRecordsResponses[keyof InfraBillingControllerGetInfraBillingHistoryRecordsResponses];

export type InfraBillingControllerCreateInfraBillingHistoryRecordData = {
    body: CreateInfraBillingHistoryRecordRequestDto;
    path?: never;
    query?: never;
    url: '/api/infra-billing/history';
};

export type InfraBillingControllerCreateInfraBillingHistoryRecordErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type InfraBillingControllerCreateInfraBillingHistoryRecordError = InfraBillingControllerCreateInfraBillingHistoryRecordErrors[keyof InfraBillingControllerCreateInfraBillingHistoryRecordErrors];

export type InfraBillingControllerCreateInfraBillingHistoryRecordResponses = {
    /**
     * Infra billing history record created successfully
     */
    201: CreateInfraBillingHistoryRecordResponseDto;
};

export type InfraBillingControllerCreateInfraBillingHistoryRecordResponse = InfraBillingControllerCreateInfraBillingHistoryRecordResponses[keyof InfraBillingControllerCreateInfraBillingHistoryRecordResponses];

export type InfraBillingControllerDeleteInfraBillingHistoryRecordByUuidData = {
    body?: never;
    path: {
        uuid: string;
    };
    query?: never;
    url: '/api/infra-billing/history/{uuid}';
};

export type InfraBillingControllerDeleteInfraBillingHistoryRecordByUuidErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type InfraBillingControllerDeleteInfraBillingHistoryRecordByUuidError = InfraBillingControllerDeleteInfraBillingHistoryRecordByUuidErrors[keyof InfraBillingControllerDeleteInfraBillingHistoryRecordByUuidErrors];

export type InfraBillingControllerDeleteInfraBillingHistoryRecordByUuidResponses = {
    /**
     * Infra billing history record deleted successfully
     */
    200: DeleteInfraBillingHistoryRecordByUuidResponseDto;
};

export type InfraBillingControllerDeleteInfraBillingHistoryRecordByUuidResponse = InfraBillingControllerDeleteInfraBillingHistoryRecordByUuidResponses[keyof InfraBillingControllerDeleteInfraBillingHistoryRecordByUuidResponses];

export type InfraBillingControllerGetBillingNodesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/infra-billing/nodes';
};

export type InfraBillingControllerGetBillingNodesErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type InfraBillingControllerGetBillingNodesError = InfraBillingControllerGetBillingNodesErrors[keyof InfraBillingControllerGetBillingNodesErrors];

export type InfraBillingControllerGetBillingNodesResponses = {
    /**
     * Infra billing nodes retrieved successfully
     */
    200: GetInfraBillingNodesResponseDto;
};

export type InfraBillingControllerGetBillingNodesResponse = InfraBillingControllerGetBillingNodesResponses[keyof InfraBillingControllerGetBillingNodesResponses];

export type InfraBillingControllerUpdateInfraBillingNodeData = {
    body: UpdateInfraBillingNodeRequestDto;
    path?: never;
    query?: never;
    url: '/api/infra-billing/nodes';
};

export type InfraBillingControllerUpdateInfraBillingNodeErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type InfraBillingControllerUpdateInfraBillingNodeError = InfraBillingControllerUpdateInfraBillingNodeErrors[keyof InfraBillingControllerUpdateInfraBillingNodeErrors];

export type InfraBillingControllerUpdateInfraBillingNodeResponses = {
    /**
     * Infra billing node updated successfully
     */
    200: UpdateInfraBillingNodeResponseDto;
};

export type InfraBillingControllerUpdateInfraBillingNodeResponse = InfraBillingControllerUpdateInfraBillingNodeResponses[keyof InfraBillingControllerUpdateInfraBillingNodeResponses];

export type InfraBillingControllerCreateInfraBillingNodeData = {
    body: CreateInfraBillingNodeRequestDto;
    path?: never;
    query?: never;
    url: '/api/infra-billing/nodes';
};

export type InfraBillingControllerCreateInfraBillingNodeErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type InfraBillingControllerCreateInfraBillingNodeError = InfraBillingControllerCreateInfraBillingNodeErrors[keyof InfraBillingControllerCreateInfraBillingNodeErrors];

export type InfraBillingControllerCreateInfraBillingNodeResponses = {
    /**
     * Infra billing node created successfully
     */
    201: CreateInfraBillingNodeResponseDto;
};

export type InfraBillingControllerCreateInfraBillingNodeResponse = InfraBillingControllerCreateInfraBillingNodeResponses[keyof InfraBillingControllerCreateInfraBillingNodeResponses];

export type InfraBillingControllerDeleteInfraBillingNodeByUuidData = {
    body?: never;
    path: {
        uuid: string;
    };
    query?: never;
    url: '/api/infra-billing/nodes/{uuid}';
};

export type InfraBillingControllerDeleteInfraBillingNodeByUuidErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type InfraBillingControllerDeleteInfraBillingNodeByUuidError = InfraBillingControllerDeleteInfraBillingNodeByUuidErrors[keyof InfraBillingControllerDeleteInfraBillingNodeByUuidErrors];

export type InfraBillingControllerDeleteInfraBillingNodeByUuidResponses = {
    /**
     * Infra billing node deleted successfully
     */
    200: DeleteInfraBillingNodeByUuidResponseDto;
};

export type InfraBillingControllerDeleteInfraBillingNodeByUuidResponse = InfraBillingControllerDeleteInfraBillingNodeByUuidResponses[keyof InfraBillingControllerDeleteInfraBillingNodeByUuidResponses];

export type UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Page size for pagination
         */
        size?: number;
        /**
         * Offset for pagination
         */
        start?: number;
    };
    url: '/api/subscription-request-history';
};

export type UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryError = UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryErrors[keyof UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryErrors];

export type UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryResponses = {
    /**
     * Subscription request history fetched successfully
     */
    200: GetSubscriptionRequestHistoryResponseDto;
};

export type UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryResponse = UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryResponses[keyof UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryResponses];

export type UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryStatsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/subscription-request-history/stats';
};

export type UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryStatsErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryStatsError = UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryStatsErrors[keyof UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryStatsErrors];

export type UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryStatsResponses = {
    /**
     * User subscription request history stats fetched successfully
     */
    200: GetSubscriptionRequestHistoryStatsResponseDto;
};

export type UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryStatsResponse = UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryStatsResponses[keyof UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryStatsResponses];

export type SystemControllerGetStatsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/system/stats';
};

export type SystemControllerGetStatsErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type SystemControllerGetStatsError = SystemControllerGetStatsErrors[keyof SystemControllerGetStatsErrors];

export type SystemControllerGetStatsResponses = {
    /**
     * Returns system statistics
     */
    200: GetStatsResponseDto;
};

export type SystemControllerGetStatsResponse = SystemControllerGetStatsResponses[keyof SystemControllerGetStatsResponses];

export type SystemControllerGetBandwidthStatsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/system/stats/bandwidth';
};

export type SystemControllerGetBandwidthStatsErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type SystemControllerGetBandwidthStatsError = SystemControllerGetBandwidthStatsErrors[keyof SystemControllerGetBandwidthStatsErrors];

export type SystemControllerGetBandwidthStatsResponses = {
    /**
     * Returns bandwidth statistics
     */
    200: GetBandwidthStatsResponseDto;
};

export type SystemControllerGetBandwidthStatsResponse = SystemControllerGetBandwidthStatsResponses[keyof SystemControllerGetBandwidthStatsResponses];

export type SystemControllerGetNodesStatisticsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/system/stats/nodes';
};

export type SystemControllerGetNodesStatisticsErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type SystemControllerGetNodesStatisticsError = SystemControllerGetNodesStatisticsErrors[keyof SystemControllerGetNodesStatisticsErrors];

export type SystemControllerGetNodesStatisticsResponses = {
    /**
     * Returns nodes statistics
     */
    200: GetNodesStatisticsResponseDto;
};

export type SystemControllerGetNodesStatisticsResponse = SystemControllerGetNodesStatisticsResponses[keyof SystemControllerGetNodesStatisticsResponses];

export type SystemControllerGetRemnawaveHealthData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/system/health';
};

export type SystemControllerGetRemnawaveHealthErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type SystemControllerGetRemnawaveHealthError = SystemControllerGetRemnawaveHealthErrors[keyof SystemControllerGetRemnawaveHealthErrors];

export type SystemControllerGetRemnawaveHealthResponses = {
    /**
     * Returns Remnawave health
     */
    200: GetRemnawaveHealthResponseDto;
};

export type SystemControllerGetRemnawaveHealthResponse = SystemControllerGetRemnawaveHealthResponses[keyof SystemControllerGetRemnawaveHealthResponses];

export type SystemControllerGetNodesMetricsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/system/nodes/metrics';
};

export type SystemControllerGetNodesMetricsErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type SystemControllerGetNodesMetricsError = SystemControllerGetNodesMetricsErrors[keyof SystemControllerGetNodesMetricsErrors];

export type SystemControllerGetNodesMetricsResponses = {
    /**
     * Returns nodes metrics from Prometheus metrics endpoint
     */
    200: GetNodesMetricsResponseDto;
};

export type SystemControllerGetNodesMetricsResponse = SystemControllerGetNodesMetricsResponses[keyof SystemControllerGetNodesMetricsResponses];

export type SystemControllerGetX25519KeypairsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/system/tools/x25519/generate';
};

export type SystemControllerGetX25519KeypairsErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type SystemControllerGetX25519KeypairsError = SystemControllerGetX25519KeypairsErrors[keyof SystemControllerGetX25519KeypairsErrors];

export type SystemControllerGetX25519KeypairsResponses = {
    /**
     * Returns x25519 keypairs
     */
    200: GenerateX25519ResponseDto;
};

export type SystemControllerGetX25519KeypairsResponse = SystemControllerGetX25519KeypairsResponses[keyof SystemControllerGetX25519KeypairsResponses];

export type SystemControllerEncryptHappCryptoLinkData = {
    body: EncryptHappCryptoLinkRequestDto;
    path?: never;
    query?: never;
    url: '/api/system/tools/happ/encrypt';
};

export type SystemControllerEncryptHappCryptoLinkErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type SystemControllerEncryptHappCryptoLinkError = SystemControllerEncryptHappCryptoLinkErrors[keyof SystemControllerEncryptHappCryptoLinkErrors];

export type SystemControllerEncryptHappCryptoLinkResponses = {
    /**
     * Returns encrypted Happ crypto link
     */
    200: EncryptHappCryptoLinkResponseDto;
};

export type SystemControllerEncryptHappCryptoLinkResponse = SystemControllerEncryptHappCryptoLinkResponses[keyof SystemControllerEncryptHappCryptoLinkResponses];

export type SystemControllerDebugSrrMatcherData = {
    body: DebugSrrMatcherRequestDto;
    path?: never;
    query?: never;
    url: '/api/system/testers/srr-matcher';
};

export type SystemControllerDebugSrrMatcherErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type SystemControllerDebugSrrMatcherError = SystemControllerDebugSrrMatcherErrors[keyof SystemControllerDebugSrrMatcherErrors];

export type SystemControllerDebugSrrMatcherResponses = {
    /**
     * Debug SRR matcher information
     */
    201: DebugSrrMatcherResponseDto;
};

export type SystemControllerDebugSrrMatcherResponse = SystemControllerDebugSrrMatcherResponses[keyof SystemControllerDebugSrrMatcherResponses];

export type SubscriptionSettingsControllerGetSettingsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/subscription-settings';
};

export type SubscriptionSettingsControllerGetSettingsErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type SubscriptionSettingsControllerGetSettingsError = SubscriptionSettingsControllerGetSettingsErrors[keyof SubscriptionSettingsControllerGetSettingsErrors];

export type SubscriptionSettingsControllerGetSettingsResponses = {
    /**
     * Subscription settings retrieved successfully
     */
    200: GetSubscriptionSettingsResponseDto;
};

export type SubscriptionSettingsControllerGetSettingsResponse = SubscriptionSettingsControllerGetSettingsResponses[keyof SubscriptionSettingsControllerGetSettingsResponses];

export type SubscriptionSettingsControllerUpdateSettingsData = {
    body: UpdateSubscriptionSettingsRequestDto;
    path?: never;
    query?: never;
    url: '/api/subscription-settings';
};

export type SubscriptionSettingsControllerUpdateSettingsErrors = {
    /**
     * Validation error
     */
    400: {
        message?: string;
        statusCode?: number;
        errors?: Array<{
            validation: string;
            code: string;
            message: string;
            path: Array<string>;
        }>;
    };
    /**
     * Server error
     */
    500: {
        timestamp?: string;
        path?: string;
        message?: string;
        errorCode?: string;
    };
};

export type SubscriptionSettingsControllerUpdateSettingsError = SubscriptionSettingsControllerUpdateSettingsErrors[keyof SubscriptionSettingsControllerUpdateSettingsErrors];

export type SubscriptionSettingsControllerUpdateSettingsResponses = {
    /**
     * Subscription settings updated successfully
     */
    200: UpdateSubscriptionSettingsResponseDto;
};

export type SubscriptionSettingsControllerUpdateSettingsResponse = SubscriptionSettingsControllerUpdateSettingsResponses[keyof SubscriptionSettingsControllerUpdateSettingsResponses];
